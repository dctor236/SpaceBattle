'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// export type BtnConfig = {
//     name: string,
//     icon: string,
//     iconScale: number,
//     folded: boolean
// }
class CSConfig {
    /* 主UI按钮配置 */
    // public static readonly EditorUIBtn: Array<BtnConfig> = []
    /* 数据操作广播 */
    static EVENT_TEMP_STORAGE_SAVE = "EventCSTempStorageSave";
    static EVENT_TEMP_STORAGE_LOAD = "EventCSTempStorageLoad";
    static EVENT_TEMP_STORAGE_LOAD_RESPONSE = "EventCSTempStorageLoadResponse";
    /** 临时数据存储Key */
    static TEMP_STORAGE_KEY = "CSTempStorage";
    static TEMP_STORAGE_KEY_SET_CAMERA_SYNC = "CSTempStorageSetCameraSync";
    static TEMP_STORAGE_KEY_SET_ = "CSTempStorage";
    /** 按键映射 */
    static KEY_ACTION_MAP = new Map([
        [0 /* KeyAction.CameraForward */, mw.Keys.W],
        [1 /* KeyAction.CameraBack */, mw.Keys.S],
        [2 /* KeyAction.CameraLeft */, mw.Keys.A],
        [3 /* KeyAction.CameraRight */, mw.Keys.D],
        [4 /* KeyAction.CameraUp */, mw.Keys.E],
        [5 /* KeyAction.CameraDown */, mw.Keys.Q],
        [6 /* KeyAction.KeyFrame */, mw.Keys.F1],
        [8 /* KeyAction.ChangeView */, mw.Keys.F8],
        [9 /* KeyAction.Back2LastFrame */, mw.Keys.F4],
        [10 /* KeyAction.PlayKeyFrames */, mw.Keys.F5],
        [11 /* KeyAction.PlayKeyFramesFromStart */, mw.Keys.F6],
        [12 /* KeyAction.StopKeyFrames */, mw.Keys.F7],
        [13 /* KeyAction.SaveAnim */, mw.Keys.F9],
        [14 /* KeyAction.ClearAnim */, mw.Keys.F12],
        [15 /* KeyAction.HoldUINode */, mw.Keys.RightMouseButton],
        [7 /* KeyAction.DelKeyFrame */, mw.Keys.Delete],
        [16 /* KeyAction.OpenEditor */, mw.Keys.Home],
        [17 /* KeyAction.CloseEditor */, mw.Keys.End],
    ]);
}

/**
 * 按键状态管理器
 */
class KeyActionManager {
    static _instance;
    static get instance() {
        if (!KeyActionManager._instance) {
            KeyActionManager._instance = new KeyActionManager();
        }
        return KeyActionManager._instance;
    }
    // 初始化标记
    isReady = false;
    // 按下状态表
    _actionStates = new Map;
    _btnStates = new Map;
    init() {
        CSConfig.KEY_ACTION_MAP.forEach((theKey, action, map) => {
            // 初始化按下状态 并设定状态改变监听
            this._actionStates.set(action, false);
            InputUtil.onKeyDown(theKey, () => {
                this._actionStates.set(action, true);
            });
            InputUtil.onKeyUp(theKey, () => {
                this._actionStates.set(action, false);
            });
        });
        this.isReady = true;
    }
    /**
     * 检测按键是否被按下，无延迟（需要在update中调用，留意性能开销）
     * @param action 项目内按键操作枚举
     * @returns 是否被按下
     */
    isPress(action) {
        if (action instanceof mw.Button) {
            return this._btnStates.get(action.guid);
        }
        else {
            return this._actionStates.get(action);
        }
    }
    /**
     * 为指定按钮添加状态监听
     * @param btn 需要监听状态的按钮
     */
    add(btn) {
        // 初始化按下状态 并设定状态改变监听
        this._btnStates.set(btn.guid, false);
        btn.onPressed.add(() => {
            this._btnStates.set(btn.guid, true);
        });
        btn.onReleased.add(() => {
            this._btnStates.set(btn.guid, false);
        });
    }
}

class GoPool {
    /** @internal */
    constructor() {
        return;
    }
    // @internal
    static instance;
    // private static gameplayObjs: Array<string> = [];
    /**
     * @description 获取对象池全局实例
     * @effect 调用端生效
     * @returns 对象池全局实例
     */
    static getInstance() {
        if (GoPool.instance == null) {
            GoPool.instance = new GoPool();
        }
        return GoPool.instance;
    }
    /**
     * @description 销毁对象池全局实例
     * @effect 调用端生效
     */
    destroy() {
        this.clearAll();
        GoPool.instance = null;
    }
    // @internal
    POOL_RES_TYPE = "POOL_RES_TYPE"; // 对象类型，归还对象的时候使用
    // @internal
    POOL_RES_GUID = "POOL_RES_GUID"; // 对象GUID，归还对象的时候使用
    // @internal
    sceneSource = new Map(); // 场景中的原始资源
    // @internal
    subPoolMap = new Map(); // [资源类型][guid][对象列表]
    defTransform = new Transform(new Vector(0, 0, -2000), new Rotation(0, 0, 0), new Vector(1, 1, 1));
    /**
     * @description 生成一个对象
     * @precautions 注意如果是资源库中的资源，需要把原始资源预加载
     * @effect 调用端生效
     * @param guid usage: 资源GUID
     * @param type usage: 资源类型 default: 资源库中的资源
     * @returns 生成的对象
     */
    spawn(guid, type = GameObjPoolSourceType.Asset) {
        let obj = this.getFreeObj(guid, type);
        if (obj == null)
            obj = this.spawnGo(guid, type);
        this.resetObj(obj);
        return obj;
    }
    /**
     * @description 异步生成一个对象
     * @precautions 注意需要把原始资源预加载
     * @effect 调用端生效
     * @param guid usage: 资源GUID
     * @param type usage: 资源类型 default: 资源库中的资源
     * @returns 生成的对象
     */
    async asyncSpawn(guid, type = GameObjPoolSourceType.Asset) {
        let obj = this.getFreeObj(guid, type);
        if (obj == null)
            obj = await this.asyncSpawnGo(guid, type);
        this.resetObj(obj);
        return obj;
    }
    /**
     * @internal
     * 获取一个闲置的对象
     */
    getFreeObj(guid, type) {
        const subPool = this.getSubPool(type, guid);
        if (subPool.length > 0) {
            const obj = subPool.pop();
            obj.setVisibility(PropertyStatus.On);
            return obj;
        }
        return null;
    }
    /**
     * @internal
     * 重置一个对象
     */
    resetObj(go) {
        if (go == null)
            return;
        if (go.parent != null) {
            // go.detachFromGameObject();
            go.parent = null;
        }
        go.setVisibility(PropertyStatus.On);
    }
    /**
     * @internal
     */
    spawnGo(guid, type) {
        let obj = null;
        switch (type) {
            case GameObjPoolSourceType.Asset:
                obj = GameObject.spawn(guid, { transform: this.defTransform.clone(), replicates: false });
                if (obj == null) {
                    console.error("GoPool: The resource has no preloaded or non-existent guid! guid=" + guid);
                }
                break;
            case GameObjPoolSourceType.Prefab:
                obj = GameObject.spawn(guid, { transform: this.defTransform.clone(), replicates: false });
                if (obj == null) {
                    console.error("GoPool: Prefab of this guid does not exist! guid=" + guid);
                }
                break;
            case GameObjPoolSourceType.Scene:
                if (this.sceneSource.has(guid)) {
                    obj = this.sceneSource.get(guid).clone();
                }
                else {
                    obj = GameObject.findGameObjectById(guid);
                    if (obj != null) {
                        this.sceneSource.set(guid, obj);
                    }
                    else {
                        console.error("GoPool: The gameObject of guid cannot be found in scene! guid=" + guid);
                    }
                }
                break;
        }
        if (obj != null) {
            obj.setVisibility(PropertyStatus.On);
            obj[this.POOL_RES_TYPE] = type;
            obj[this.POOL_RES_GUID] = guid;
        }
        return obj;
    }
    /**
     * @internal
     */
    async asyncSpawnGo(guid, type) {
        let obj = null;
        switch (type) {
            case GameObjPoolSourceType.Asset:
                if (!AssetUtil.assetLoaded(guid)) {
                    const isSuccess = await AssetUtil.asyncDownloadAsset(guid);
                    if (isSuccess) {
                        obj = await GameObject.asyncSpawn(guid, { transform: this.defTransform.clone(), replicates: false });
                    }
                    else {
                        console.error("GoPool: Resource loading failed! guid=" + guid);
                    }
                }
                else {
                    obj = GameObject.spawn(guid, { transform: this.defTransform.clone(), replicates: false });
                }
                break;
            case GameObjPoolSourceType.Prefab:
                obj = await GameObject.asyncSpawn(guid, { transform: this.defTransform.clone(), replicates: false });
                if (obj == null) {
                    console.error("GoPool: Prefab of this guid does not exist! guid=" + guid);
                }
                break;
            case GameObjPoolSourceType.Scene:
                if (this.sceneSource.has(guid)) {
                    obj = this.sceneSource.get(guid).clone();
                }
                else {
                    obj = await GameObject.asyncFindGameObjectById(guid);
                    if (obj != null) {
                        this.sceneSource.set(guid, obj);
                    }
                    else {
                        console.error("GoPool: The gameObject of guid cannot be found in scene! guid=" + guid);
                    }
                }
                break;
        }
        if (obj != null) {
            obj.setVisibility(PropertyStatus.On);
            obj[this.POOL_RES_TYPE] = type;
            obj[this.POOL_RES_GUID] = guid;
        }
        return obj;
    }
    /**
     * @internal
     * 获取一个子对象池
     */
    getSubPool(type, guid) {
        if (!this.subPoolMap.has(type)) {
            this.subPoolMap.set(type, new Map());
        }
        if (!this.subPoolMap.get(type).has(guid)) {
            this.subPoolMap.get(type).set(guid, []);
        }
        return this.subPoolMap.get(type).get(guid);
    }
    /**
     * @description 归还一个对象
     * @effect 调用端生效
     * @param obj usage: 要归还的对象
     */
    despawn(obj) {
        if (obj == null)
            return;
        const type = obj[this.POOL_RES_TYPE];
        const guid = obj[this.POOL_RES_GUID];
        if (guid == null || type == null)
            return;
        const subPool = this.getSubPool(type, guid);
        if (subPool.includes(obj))
            return;
        subPool.push(obj);
        obj.worldTransform.position = new Vector(0, 0, -2000);
        // obj.detachFromGameObject();
        obj.setVisibility(PropertyStatus.Off);
    }
    /**
     * @description 清除对象池中该GUID对应的所有对象
     * @effect 调用端生效
     * @param guid usage: 资源GUID
     * @param type usage: 资源类型 default: 资源库中的资源
     */
    clear(guid, type = GameObjPoolSourceType.Asset) {
        const subPool = this.getSubPool(type, guid);
        for (let i = 0; i < subPool.length; i++) {
            subPool[i].destroy();
        }
        subPool.length = 0;
    }
    /**
     * @description 清除对象池里的所有对象
     * @effect 调用端生效
     */
    clearAll() {
        this.subPoolMap.forEach((subPool) => {
            subPool.forEach((objArr) => {
                for (let i = 0; i < objArr.length; i++) {
                    objArr[i].destroy();
                }
            });
        });
        this.subPoolMap.clear();
    }
}

/**
 * 摄像机锚点
 * 摄像机的控制对象（将摄像机附着到该物体上使用）
 */
class CameraAnchor {
    camera;
    /* 摄像机锚点移动速度 */
    speed = 500;
    _anchorObj;
    _moveLoc;
    /* 移动叠加向量 */
    _moveDirection = mw.Vector.zero;
    VECTOR_ZERO = mw.Vector.zero;
    constructor() {
        this._anchorObj = GoPool.getInstance().spawn(Assets.MESH_BLOCK, GameObjPoolSourceType.Asset);
        // this._anchorObj.setVisibility(mw.PropertyStatus.Off);
        this._moveLoc = this._anchorObj.worldTransform.position.clone();
        this.camera = GameObject.spawn("Camera");
        this.camera.parent = this._anchorObj;
        this.camera.springArm.localTransform = Transform.identity;
        // Config
        this.camera.upAngleLimit = 89.9;
        this.camera.downAngleLimit = 89.9;
        this.camera.springArm.collisionEnabled = false;
    }
    update(dt) {
        // 监听按键并叠加控制锚点位移的向量
        if (KeyActionManager.instance.isPress(0 /* KeyAction.CameraForward */)) {
            // 将三维向量压缩至二维使用
            const forward = this.camera.worldTransform.clone().getForwardVector().clone();
            this._moveDirection.x += forward.x;
            this._moveDirection.y += forward.y;
        }
        if (KeyActionManager.instance.isPress(1 /* KeyAction.CameraBack */)) {
            const back = this.camera.worldTransform.clone().getForwardVector().clone().multiply(-1);
            this._moveDirection.x += back.x;
            this._moveDirection.y += back.y;
        }
        if (KeyActionManager.instance.isPress(2 /* KeyAction.CameraLeft */)) {
            const left = this.camera.worldTransform.clone().getRightVector().clone().multiply(-1);
            this._moveDirection.x += left.x;
            this._moveDirection.y += left.y;
        }
        if (KeyActionManager.instance.isPress(3 /* KeyAction.CameraRight */)) {
            const right = this.camera.worldTransform.clone().getRightVector().clone();
            this._moveDirection.x += right.x;
            this._moveDirection.y += right.y;
        }
        if (KeyActionManager.instance.isPress(4 /* KeyAction.CameraUp */)) {
            this._moveDirection.z += 1;
        }
        if (KeyActionManager.instance.isPress(5 /* KeyAction.CameraDown */)) {
            this._moveDirection.z -= 1;
        }
        // 为锚点设置叠加后向量，实现无限制位移
        if (!this._moveDirection.equals(this.VECTOR_ZERO)) {
            this._moveLoc = mw.Vector.add(this._moveLoc, this._moveDirection.normalized.multiply(this.speed * dt));
            this._anchorObj.worldTransform.position = this._moveLoc;
            this._moveDirection.x = 0;
            this._moveDirection.y = 0;
            this._moveDirection.z = 0;
        }
    }
    getAnchorGameObject() {
        return this._anchorObj;
    }
    getLocation() {
        return this._anchorObj.worldTransform.position.clone();
    }
    getRotation() {
        return this.camera.worldTransform.rotation.clone();
    }
    setLocation(location) {
        this._moveLoc = location;
        this._anchorObj.worldTransform.position = location;
    }
    setRotation(rotation) {
        // this._anchorObj.worldTransform.rotation = rotation;
        Player.setControllerRotation(rotation);
    }
    setFOV(fov) {
        this.camera.fov = fov;
    }
    resetOverrideRotation() {
        // ModifiedCameraSystem.resetOverrideCameraRotation();
    }
    destroy() {
        this._anchorObj.destroy();
    }
}

class Log {
    static info(...text) {
        let outStr = "[CameraStudio]";
        for (const iterator of text) {
            outStr += " ";
            outStr += iterator;
        }
        console.log(outStr);
    }
    static warn(...text) {
        let outStr = "[CameraStudio]";
        for (const iterator of text) {
            outStr += " ";
            outStr += iterator;
        }
        console.warn(outStr);
    }
    static err(...text) {
        let outStr = "[CameraStudio]";
        for (const iterator of text) {
            outStr += " ";
            outStr += iterator;
        }
        console.error(outStr);
    }
}

/**
 * 单个关键帧信息
 */
class KeyFrameInfo {
    // 动画开始到当前帧时间
    _time;
    _location;
    _rotation;
    _fov;
    /**
     * 反序列化本对象（注意：反序列化会引起错误，请在外部捕获）
     * @param jsonStr 源文本
     * @returns 返回序列化后的对象
     */
    static deserialize(jsonStr) {
        const object = JSON.parse(jsonStr);
        return new KeyFrameInfo(object['_time'], new mw.Vector(object['_location']['x'], object['_location']['y'], object['_location']['z']), new mw.Rotation(object['_rotation']['x'], object['_rotation']['y'], object['_rotation']['z']), object['_fov']);
    }
    constructor(time, location, rotation, fov) {
        this.time = time;
        this.location = location;
        this.rotation = rotation;
        this._fov = fov;
    }
    get time() {
        return this._time;
    }
    set time(newTime) {
        this._time = Number(newTime.toFixed(2));
    }
    get location() {
        return this._location;
    }
    set location(newLocation) {
        newLocation.x = Number(newLocation.x.toFixed(2));
        newLocation.y = Number(newLocation.y.toFixed(2));
        newLocation.z = Number(newLocation.z.toFixed(2));
        this._location = newLocation;
    }
    get rotation() {
        return this._rotation;
    }
    set rotation(newRotation) {
        newRotation.x = Number(newRotation.x.toFixed(2));
        newRotation.y = Number(newRotation.y.toFixed(2));
        newRotation.z = Number(newRotation.z.toFixed(2));
        this._rotation = newRotation;
    }
    get fov() {
        return this._fov;
    }
    set fov(newFOV) {
        this._fov = Number(newFOV.toFixed(2));
    }
}
exports.KeyFrameInfoType = void 0;
(function (KeyFrameInfoType) {
    KeyFrameInfoType[KeyFrameInfoType["Time"] = 0] = "Time";
    KeyFrameInfoType[KeyFrameInfoType["LocationX"] = 1] = "LocationX";
    KeyFrameInfoType[KeyFrameInfoType["LocationY"] = 2] = "LocationY";
    KeyFrameInfoType[KeyFrameInfoType["LocationZ"] = 3] = "LocationZ";
    KeyFrameInfoType[KeyFrameInfoType["RotationX"] = 4] = "RotationX";
    KeyFrameInfoType[KeyFrameInfoType["RotationY"] = 5] = "RotationY";
    KeyFrameInfoType[KeyFrameInfoType["RotationZ"] = 6] = "RotationZ";
    KeyFrameInfoType[KeyFrameInfoType["FOV"] = 7] = "FOV";
})(exports.KeyFrameInfoType || (exports.KeyFrameInfoType = {}));

/**
 * 关键帧动画类
 */
class KeyFrame {
    _frameInfos;
    /**
     * 反序列化本对象（注意：反序列化会引起错误，请在外部捕获）
     * @param animJsonStr 源文本
     * @returns 返回序列化后的对象
     */
    static deserialize(animJsonStr) {
        // 逐层反序列化
        const object = JSON.parse(animJsonStr);
        const anim = new KeyFrame();
        const frameInfos = object['_frameInfos'];
        frameInfos.forEach(element => {
            anim.push(KeyFrameInfo.deserialize(JSON.stringify(element)), true);
        });
        return anim;
    }
    constructor() {
        this._frameInfos = [];
    }
    //#region 组操作
    push(keyFrameInfo, isDeserialize = false) {
        // 判断时是否重复插入
        for (let i = 0; i < this.getLength(); i++) {
            if (this._frameInfos[i].time === keyFrameInfo.time) {
                Log.err("在相同时间重复插入");
                return false;
            }
        }
        // 将帧放入，并排序将时间重解算
        this._frameInfos.push(keyFrameInfo);
        this.sort();
        if (!isDeserialize)
            Log.info("加入关键帧", JSON.stringify(keyFrameInfo));
        return true;
    }
    del(index) {
        this._frameInfos.splice(index, 1);
    }
    get(index) {
        return this._frameInfos[index];
    }
    getEnd() {
        return this._frameInfos[this._frameInfos.length - 1];
    }
    getLength() {
        return this._frameInfos.length;
    }
    forEach(callbackfn) {
        this._frameInfos.forEach((value, index, arr) => {
            callbackfn(value, index, arr);
        });
    }
    /**
     * 对动画帧以时间进行排序
     */
    sort() {
        this._frameInfos.sort((aInfo, bInfo) => {
            return aInfo.time - bInfo.time;
        });
    }
    /**
     * 查找指定关键帧索引
     */
    indexOf(info) {
        return this._frameInfos.indexOf(info);
    }
    /**
     * 清空所有关键帧信息
     */
    clear() {
        this._frameInfos.length = 0;
    }
    /**
     * 将另一对象拷贝到本地
     */
    copy(keyFrame) {
        this.clear();
        keyFrame.forEach((value) => {
            this.push(value);
        });
    }
    //#endregion
    //#region 帧操作
    modifyTime(index, time) {
        let info = this._frameInfos[index];
        this._frameInfos[index].time = time;
        Log.info("修改关键帧时间", JSON.stringify(this._frameInfos[index]));
        this.sort();
        return this.indexOf(info);
    }
    modifyLoc(index, loc) {
        this._frameInfos[index].location.set(loc);
        Log.info("修改关键帧位置", JSON.stringify(this._frameInfos[index]));
    }
    modifyRot(index, rot) {
        this._frameInfos[index].rotation.set(rot);
        Log.info("修改关键帧旋转", JSON.stringify(this._frameInfos[index]));
    }
    modifyFOV(index, fov) {
        this._frameInfos[index].fov = fov;
        Log.info("修改关键帧FOV", JSON.stringify(this._frameInfos[index]));
    }
    //#endregion
    /**
     * 获取两关键帧之间距离
     * @param index1 在该动画中的索引
     * @param index2 在该动画中的索引
     */
    getLocationDifference(index1, index2) {
        return mw.Vector.distance(this._frameInfos[index1].location, this._frameInfos[index2].location);
    }
    /**
     * 获取从获取上一帧到该帧的时间
     * @param index 当前帧下标（为空则是动画总时间）
     * @returns 时间
     */
    getFrameTime(index) {
        if (index === 0) {
            Log.err("对第一帧进行帧间时间获取");
            return 0;
        }
        return this.get(index).time - this.get(index - 1).time;
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

exports.CSTimeTextUI_Generate = class CSTimeTextUI_Generate extends mw.UIScript {
    mTextTime = undefined;
    /**
    * onStart 之前触发一次
    */
    onAwake() {
    }
};
__decorate([
    UIWidgetBind('Canvas/mTextTime')
], exports.CSTimeTextUI_Generate.prototype, "mTextTime", void 0);
exports.CSTimeTextUI_Generate = __decorate([
    UIBind('UI/module_cameracg/item/CSTimeTextUI.ui')
], exports.CSTimeTextUI_Generate);

/**
 * 计时条时间文本
 */
class UITimeText extends exports.CSTimeTextUI_Generate {
    setState(pos, second) {
        this.uiObject.position = pos;
        this.setTime(second);
    }
    setTime(second) {
        const s = second % 60;
        const m = Math.floor(second / 60);
        this.mTextTime.text = `${m}:${(s < 10 ? '0' : '') + s}`;
    }
    show() {
        mw.UIService.showUI(this);
    }
    hide() {
        mw.UIService.hideUI(this);
    }
}

exports.CSTimePointUI_Generate = class CSTimePointUI_Generate extends mw.UIScript {
    mImgLine = undefined;
    /**
    * onStart 之前触发一次
    */
    onAwake() {
    }
};
__decorate([
    UIWidgetBind('Canvas/mImgLine')
], exports.CSTimePointUI_Generate.prototype, "mImgLine", void 0);
exports.CSTimePointUI_Generate = __decorate([
    UIBind('UI/module_cameracg/item/CSTimePointUI.ui')
], exports.CSTimePointUI_Generate);

/**
 * 计时条时间刻度
 */
class UITimePoint extends exports.CSTimePointUI_Generate {
    _defSize;
    onStart() {
        this._defSize = this.uiObject.size;
    }
    setState(pos, state) {
        this.uiObject.position = pos;
        switch (state) {
            case exports.UITimePointState.Default:
                this.uiObject.size = this._defSize.clone();
                this.mImgLine.size = this._defSize.clone();
                break;
            case exports.UITimePointState.Long:
                this.uiObject.size = new mw.Vector2(this._defSize.x, this._defSize.y * 2);
                this.mImgLine.size = new mw.Vector2(this._defSize.x, this._defSize.y * 2);
                break;
        }
    }
    show() {
        mw.UIService.showUI(this);
    }
    hide() {
        mw.UIService.hideUI(this);
    }
}
exports.UITimePointState = void 0;
(function (UITimePointState) {
    UITimePointState[UITimePointState["Default"] = 0] = "Default";
    UITimePointState[UITimePointState["Long"] = 1] = "Long";
})(exports.UITimePointState || (exports.UITimePointState = {}));

exports.CSKeyFrameUI_Generate = class CSKeyFrameUI_Generate extends mw.UIScript {
    mImgSelect = undefined;
    mBtn = undefined;
    /**
    * onStart 之前触发一次
    */
    onAwake() {
    }
};
__decorate([
    UIWidgetBind('Canvas/mImgSelect')
], exports.CSKeyFrameUI_Generate.prototype, "mImgSelect", void 0);
__decorate([
    UIWidgetBind('Canvas/mBtn')
], exports.CSKeyFrameUI_Generate.prototype, "mBtn", void 0);
exports.CSKeyFrameUI_Generate = __decorate([
    UIBind('UI/module_cameracg/item/CSKeyFrameUI.ui')
], exports.CSKeyFrameUI_Generate);

/**
 * 计时条关键帧
 */
class UIKeyFrame extends exports.CSKeyFrameUI_Generate {
    onSelect;
    isSelected;
    /** 保有当前在动画中的位置索引 */
    index;
    onAwake() {
        super.onAwake();
        this.onSelect = new Action();
        this.mBtn.onClicked.add(() => {
            this.onSelect.call();
        });
    }
    setState(pos, index) {
        this.uiObject.position = pos;
        this.index = index;
    }
    setSelected(isTrue) {
        if (isTrue) {
            this.mImgSelect.visibility = mw.SlateVisibility.SelfHitTestInvisible;
        }
        else {
            this.mImgSelect.visibility = mw.SlateVisibility.Hidden;
        }
    }
    show() {
        mw.UIService.showUI(this);
    }
    hide() {
        mw.UIService.hideUI(this);
    }
}

class UIUtils {
    /**
     * 无限制移动UI中心点到鼠标位置随鼠标
     * @param node 需要移动的UI
     */
    static moveFree(node) {
        const viewport = mw.getMousePositionOnViewport().clone();
        const movePos = this.viewport2LocalUpperLeft(node, viewport);
        node.position = (mw.Vector2.subtract(
        // 保持点击点是按钮的中点
        movePos, node.size.clone().divide(2)));
    }
    /**
     * 限制父布局位置与X轴计算UI中心点到鼠标位置随鼠标
     * @param node 需要移动的UI
     * @return 移动后位置在父布局比（0~1）
     */
    static moveXInParent(node) {
        const parent = node.parent;
        const viewport = mw.getMousePositionOnViewport().clone();
        const movePos = this.viewport2LocalUpperLeft(node, viewport);
        movePos.y = node.position.y;
        movePos.x -= node.size.x / 2;
        const halfX = node.size.x / 2;
        // 范围限制
        if (movePos.x < -halfX) {
            movePos.x = -halfX;
        }
        else if (movePos.x > parent.size.x - halfX) {
            movePos.x = parent.size.x - halfX;
        }
        node.position = movePos;
        return (movePos.x + halfX) / parent.size.x;
    }
    /**
     * 屏幕坐标转换为相对坐标（实验性）
     * @param node 转换节点
     * @param viewport 窗口坐标
     * @returns 转换后坐标
     */
    static viewport2LocalUpperLeft(node, viewport) {
        // 父节点集位置求取
        let parentsPos = new mw.Vector2();
        let parentNode = node.parent;
        while (parentNode) {
            parentsPos.add(parentNode.position.clone());
            parentNode = parentNode.parent;
        }
        return viewport.subtract(parentsPos);
    }
}

exports.CSDialogLoad_Generate = class CSDialogLoad_Generate extends mw.UIScript {
    mBtnClose = undefined;
    mBtnLoad = undefined;
    mInput = undefined;
    /**
    * onStart 之前触发一次
    */
    onAwake() {
    }
};
__decorate([
    UIWidgetBind('MWCanvas_2147482460/mBtnClose')
], exports.CSDialogLoad_Generate.prototype, "mBtnClose", void 0);
__decorate([
    UIWidgetBind('MWCanvas_2147482460/CanvasDialog/CanvasBtn5/mBtnLoad')
], exports.CSDialogLoad_Generate.prototype, "mBtnLoad", void 0);
__decorate([
    UIWidgetBind('MWCanvas_2147482460/CanvasDialog/mInput')
], exports.CSDialogLoad_Generate.prototype, "mInput", void 0);
exports.CSDialogLoad_Generate = __decorate([
    UIBind('UI/module_cameracg/CSDialogLoad.ui')
], exports.CSDialogLoad_Generate);

/**
 * 导入时使用的弹出对话框
 */
class UICSDialogLoad extends exports.CSDialogLoad_Generate {
    _defHintStr;
    onAwake() {
        this._defHintStr = this.mInput.hintString;
        this.mBtnClose.onClicked.add(() => {
            this.hide();
        });
        this.mBtnLoad.onClicked.add(() => {
            if (CSEditor.instance.loadAnim(this.mInput.text)) {
                this.hide();
            }
            else {
                this.mInput.text = "";
                this.mInput.hintString = "字符串异常，导入失败";
            }
        });
    }
    show() {
        this.mInput.hintString = this._defHintStr;
        mw.UIService.showUI(this);
    }
    hide() {
        mw.UIService.hideUI(this);
    }
}

/**
 * 运行时动态配置
 */
class CSSettings {
    /** 摄像机同步功能 */
    static isCameraSync = true;
    /** 插值器 */
    static isLinear = true;
}

exports.CSEditorUI_Generate = class CSEditorUI_Generate extends mw.UIScript {
    mBtnPlay = undefined;
    mBtnRecord = undefined;
    mBtnClear = undefined;
    mBtnSetting = undefined;
    mCanvasBtns = undefined;
    mBtnSpline = undefined;
    textSpline = undefined;
    mBtnCameraSync = undefined;
    textCameraSync = undefined;
    mBtnResetFOV = undefined;
    mBtnLoad = undefined;
    mBtnSave = undefined;
    mCanvasSetting = undefined;
    mCanvasTimePoint = undefined;
    mBtnBar = undefined;
    mBtnCurrentTime = undefined;
    mCanvasKeyFrame = undefined;
    mBtnAddTime = undefined;
    mBtnSubTime = undefined;
    mCanvasTimeLine = undefined;
    mInputLocX = undefined;
    mInputLocY = undefined;
    mInputLocZ = undefined;
    mInputRotP = undefined;
    mInputRotY = undefined;
    mInputRotR = undefined;
    mInputFOV = undefined;
    mBtnDelKeyFrame = undefined;
    mCanvasFramesEdit = undefined;
    mCanvasActionBar = undefined;
    /**
    * onStart 之前触发一次
    */
    onAwake() {
    }
};
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasBtns/CanvasBtnPlay/mBtnPlay')
], exports.CSEditorUI_Generate.prototype, "mBtnPlay", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasBtns/CanvasBtnRecord/mBtnRecord')
], exports.CSEditorUI_Generate.prototype, "mBtnRecord", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasBtns/CanvasBtnClear/mBtnClear')
], exports.CSEditorUI_Generate.prototype, "mBtnClear", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasBtns/CanvasBtnSetting/mBtnSetting')
], exports.CSEditorUI_Generate.prototype, "mBtnSetting", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasBtns')
], exports.CSEditorUI_Generate.prototype, "mCanvasBtns", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasSetting/CanvasSpline/mBtnSpline')
], exports.CSEditorUI_Generate.prototype, "mBtnSpline", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasSetting/CanvasSpline/textSpline')
], exports.CSEditorUI_Generate.prototype, "textSpline", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasSetting/CanvasCameraSync/mBtnCameraSync')
], exports.CSEditorUI_Generate.prototype, "mBtnCameraSync", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasSetting/CanvasCameraSync/textCameraSync')
], exports.CSEditorUI_Generate.prototype, "textCameraSync", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasSetting/CanvasResetFOV/mBtnResetFOV')
], exports.CSEditorUI_Generate.prototype, "mBtnResetFOV", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasSetting/CanvasBtnLoad/mBtnLoad')
], exports.CSEditorUI_Generate.prototype, "mBtnLoad", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasSetting/CanvasSave/mBtnSave')
], exports.CSEditorUI_Generate.prototype, "mBtnSave", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasSetting')
], exports.CSEditorUI_Generate.prototype, "mCanvasSetting", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasTimeLine/mCanvasTimePoint')
], exports.CSEditorUI_Generate.prototype, "mCanvasTimePoint", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasTimeLine/mBtnBar')
], exports.CSEditorUI_Generate.prototype, "mBtnBar", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasTimeLine/mBtnCurrentTime')
], exports.CSEditorUI_Generate.prototype, "mBtnCurrentTime", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasTimeLine/mCanvasKeyFrame')
], exports.CSEditorUI_Generate.prototype, "mCanvasKeyFrame", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasTimeLine/CanvasBtnAddTime/mBtnAddTime')
], exports.CSEditorUI_Generate.prototype, "mBtnAddTime", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasTimeLine/CanvasBtnSubTime/mBtnSubTime')
], exports.CSEditorUI_Generate.prototype, "mBtnSubTime", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasTimeLine')
], exports.CSEditorUI_Generate.prototype, "mCanvasTimeLine", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasFramesEdit/CanvasEditLoc/mInputLocX')
], exports.CSEditorUI_Generate.prototype, "mInputLocX", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasFramesEdit/CanvasEditLoc/mInputLocY')
], exports.CSEditorUI_Generate.prototype, "mInputLocY", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasFramesEdit/CanvasEditLoc/mInputLocZ')
], exports.CSEditorUI_Generate.prototype, "mInputLocZ", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasFramesEdit/CanvasEditRot/mInputRotP')
], exports.CSEditorUI_Generate.prototype, "mInputRotP", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasFramesEdit/CanvasEditRot/mInputRotY')
], exports.CSEditorUI_Generate.prototype, "mInputRotY", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasFramesEdit/CanvasEditRot/mInputRotR')
], exports.CSEditorUI_Generate.prototype, "mInputRotR", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasFramesEdit/CanvasEditOther/mInputFOV')
], exports.CSEditorUI_Generate.prototype, "mInputFOV", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasFramesEdit/CanvasEditOther/CanvasBtnDelKeyFrame/mBtnDelKeyFrame')
], exports.CSEditorUI_Generate.prototype, "mBtnDelKeyFrame", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar/mCanvasFramesEdit')
], exports.CSEditorUI_Generate.prototype, "mCanvasFramesEdit", void 0);
__decorate([
    UIWidgetBind('MWCanvas/mCanvasActionBar')
], exports.CSEditorUI_Generate.prototype, "mCanvasActionBar", void 0);
exports.CSEditorUI_Generate = __decorate([
    UIBind('UI/module_cameracg/CSEditorUI.ui')
], exports.CSEditorUI_Generate);

var UIPoolFlag;
(function (UIPoolFlag) {
    UIPoolFlag["visible"] = "UIPoolFlagVisible";
})(UIPoolFlag || (UIPoolFlag = {}));
class UIPool {
    _uiClass;
    /* 节点表 */
    nodes = [];
    size = null;
    constructor(_uiClass) {
        this._uiClass = _uiClass;
    }
    /**
     * 销毁池中所有对象
     */
    destroy() {
        for (var i = 0; i < this.nodes.length; i++) {
            this.nodes[i].destroy();
        }
        this.nodes.length = 0;
    }
    /**
     * 请求一个UI对象
     * @returns 生成的对象
     */
    spawn() {
        for (var i = 0; i < this.nodes.length; i++) {
            if (!this.nodes[i][UIPoolFlag.visible]) {
                this.nodes[i].uiObject.size = this.size;
                this.nodes[i].setVisible(true);
                this.nodes[i][UIPoolFlag.visible] = true;
                return this.nodes[i];
            }
        }
        let node = mw.UIService.create(this._uiClass);
        if (this.size == null)
            this.size = node.uiObject.size.clone();
        node.uiObject.size = this.size;
        node.rootCanvas.visibility = (mw.SlateVisibility.Visible);
        node.setVisible(true);
        node[UIPoolFlag.visible] = true;
        this.nodes.push(node);
        return node;
    }
    ;
    /**
     * 归还一个对象
     */
    despawn(node) {
        const index = this.nodes.indexOf(node);
        if (index >= 0) {
            node.uiObject.size = mw.Vector2.zero;
            node.setVisible(false);
            node[UIPoolFlag.visible] = false;
        }
    }
    /**
     * 清除对象池中所有对象
     */
    clear() {
        for (var i = 0; i < this.nodes.length; i++) {
            this.nodes[i].uiObject.size = mw.Vector2.zero;
            this.nodes[i].setVisible(false);
            this.nodes[i][UIPoolFlag.visible] = false;
        }
    }
    ;
}
class GridContainer extends UIPool {
    _canvas;
    _uiClass;
    constructor(_canvas, _uiClass) {
        super(_uiClass);
        this._canvas = _canvas;
        this._uiClass = _uiClass;
    }
    /**
     * 添加节点
     * @return 节点
     */
    addNode() {
        const node = this.spawn();
        this._canvas.addChild(node.uiObject);
        return node;
    }
    /**
     * 移除单个节点
     */
    removeNode(node) {
        this.despawn(node);
    }
    /**
     * 移除所有节点
     */
    removeAllNode() {
        for (var i = 0; i < this.nodes.length; i++) {
            this.nodes[i].uiObject.size = mw.Vector2.zero;
            this.nodes[i].setVisible(false);
            this.nodes[i][UIPoolFlag.visible] = false;
        }
    }
}
class GridSelectContainer extends UIPool {
    _canvas;
    _uiClass;
    constructor(_canvas, _uiClass) {
        super(_uiClass);
        this._canvas = _canvas;
        this._uiClass = _uiClass;
    }
    /**
     * 添加节点
     * @return 节点
     */
    addNode() {
        const node = this.spawn();
        this._canvas.addChild(node.uiObject);
        node.onSelect.add(() => {
            this.selectNode(node);
        });
        return node;
    }
    /**
     * 更新节点选中态
     * @param node
     */
    selectNode(node) {
        for (var i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i][UIPoolFlag.visible]) {
                if (this.nodes[i] == node) {
                    this.nodes[i].isSelected = true;
                    this.nodes[i].setSelected(true);
                }
                else {
                    this.nodes[i].isSelected = false;
                    this.nodes[i].setSelected(false);
                }
            }
        }
    }
    /**
     * 移除单个节点
     */
    removeNode(node) {
        node.onSelect.clear();
        this.despawn(node);
    }
    /**
     * 移除所有节点
     */
    removeAllNode() {
        for (var i = 0; i < this.nodes.length; i++) {
            this.nodes[i].onSelect.clear();
            this.nodes[i].uiObject.size = mw.Vector2.zero;
            this.nodes[i].setVisible(false);
            this.nodes[i].setSelected(false);
            this.nodes[i][UIPoolFlag.visible] = false;
        }
    }
}

/**
 * 编辑器主UI
 */
class UICSEditor extends exports.CSEditorUI_Generate {
    // 显示的总时间时长（s）
    _totalTime = 60;
    _currentTime = 0;
    get currentTime() {
        return this._currentTime;
    }
    _uiDialogLoad;
    // 需要移动的UI引用
    _moveNode;
    // 被的选中移动的关键帧光标根节点
    _moveKeyFramesUIObject;
    // 被的选中修改的关键帧光标节点
    selectKeyFramesIndex = -1;
    _locCache = new mw.Vector();
    _rotCache = new mw.Rotation();
    // 关键帧光标移动结束延迟
    _keyFramesNodeMoveTime = 0;
    /* UIPool */
    _keyFramesUIPool;
    _timePointUIPool;
    _timTextUIPool;
    onStart() {
        this.initUI();
        // 注册移动选中监听
        this.addHoverListener(this.mBtnBar, this.mBtnCurrentTime);
        // 初始化绘制
        this.updateTimeLine();
        this.updateCurrentTime(0);
        this.canUpdate = true;
    }
    onUpdate(dt) {
        // 延迟执行关键帧光标值修改（防止过度调用）
        if (this._keyFramesNodeMoveTime > 0) {
            this._keyFramesNodeMoveTime -= dt;
            if (this._keyFramesNodeMoveTime <= 0) {
                const index = Number(this._moveKeyFramesUIObject.name);
                const time = UIUtils.moveXInParent(this._moveKeyFramesUIObject) * this._totalTime;
                const newIndex = CSEditor.instance.modifyKeyFramesTime(index, time);
                this.selectKeyFrames(newIndex);
            }
        }
        // 监听控制光标操作并移动对应元素
        if (KeyActionManager.instance.isPress(15 /* KeyAction.HoldUINode */)) {
            if (!this._moveNode) {
                return;
            }
            // 移动后关于父布局的X位置比（0~1）
            const progress = UIUtils.moveXInParent(this._moveNode);
            if (this._moveNode.name === "mBtnCurrentTime") {
                // 时间光标移动
                this._currentTime = this._totalTime * progress;
                CSEditedPlayer.instance.setCurrentPlayTotalTime(this._currentTime);
                return;
            }
            else {
                // 关键帧光标移动
                if (this._moveKeyFramesUIObject !== this._moveNode) {
                    this._moveKeyFramesUIObject = this._moveNode;
                }
                // 延迟0.1s执行应用值修改（防止过度调用）
                this._keyFramesNodeMoveTime = 0.1;
                return;
            }
        }
    }
    show() {
        mw.UIService.showUI(this);
    }
    hide() {
        mw.UIService.hideUI(this);
    }
    initUI() {
        this._keyFramesUIPool = new GridSelectContainer(this.mCanvasKeyFrame, UIKeyFrame);
        this._timePointUIPool = new GridContainer(this.mCanvasTimePoint, UITimePoint);
        this._timTextUIPool = new GridContainer(this.mCanvasTimePoint, UITimeText);
        this._uiDialogLoad = mw.UIService.getUI(UICSDialogLoad);
        // 处理原生按钮监听
        this.mBtnPlay.onClicked.add(() => {
            CSEditedPlayer.instance.switchPlayStop();
        });
        this.mBtnRecord.onClicked.add(() => {
            CSEditor.instance.recordKeyframe();
        });
        this.mBtnClear.onClicked.add(() => {
            CSEditor.instance.clearCurrentAnim();
        });
        this.mBtnSetting.onClicked.add(() => {
            if (this.mCanvasSetting.visibility === mw.SlateVisibility.Hidden) {
                this.mCanvasSetting.visibility = mw.SlateVisibility.Visible;
            }
            else {
                this.mCanvasSetting.visibility = mw.SlateVisibility.Hidden;
            }
        });
        // Setting
        if (CSSettings.isLinear) {
            this.textSpline.text = "插值 [<color=#3881fa>线性</color>]";
        }
        else {
            this.textSpline.text = "插值 [<color=#3881fa>三次</color>]";
        }
        this.mBtnSpline.onClicked.add(() => {
            CSSettings.isLinear = !CSSettings.isLinear;
            if (CSSettings.isLinear) {
                this.textSpline.text = "插值 [<color=#3881fa>线性</color>]";
            }
            else {
                this.textSpline.text = "插值 [<color=#3881fa>三次</color>]";
            }
        });
        if (CSSettings.isCameraSync) {
            this.textCameraSync.text = "相机同步 [<color=#3fa066>开</color>]";
        }
        else {
            this.textCameraSync.text = "相机同步 [<color=#fb757b>关</color>]";
        }
        this.mBtnCameraSync.onClicked.add(() => {
            // 更改摄像机同步设置
            CSEditor.instance.switchCameraSync();
            if (CSSettings.isCameraSync) {
                this.textCameraSync.text = "相机同步 [<color=#3fa066>开</color>]";
            }
            else {
                this.textCameraSync.text = "相机同步 [<color=#fb757b>关</color>]";
            }
        });
        this.mBtnResetFOV.onClicked.add(() => {
            CSEditor.instance.resetCameraFOV();
        });
        this.mBtnLoad.onClicked.add(() => {
            this._uiDialogLoad.show();
        });
        this.mBtnSave.onClicked.add(() => {
            CSEditor.instance.saveCurrentAnim();
        });
        // 关键帧编辑区输入框映射
        // TimeCtrl
        this.mBtnAddTime.onClicked.add(() => {
            if (this._totalTime >= 150) {
                return;
            }
            if (CSEditor.instance.checkUpdateTimeline(this._totalTime + 30)) {
                this._totalTime += 30;
                this.updateTimeLine();
                CSEditor.instance.updateTimeline();
            }
        });
        this.mBtnSubTime.onClicked.add(() => {
            if (this._totalTime <= 30) {
                return;
            }
            if (CSEditor.instance.checkUpdateTimeline(this._totalTime - 30)) {
                this._totalTime -= 30;
                this.updateTimeLine();
                CSEditor.instance.updateTimeline();
            }
        });
        // Loc
        this.mInputLocX.onTextChanged.add((text) => {
            this.handleKeyFrameChanged(exports.KeyFrameInfoType.LocationX, text);
        });
        this.mInputLocY.onTextChanged.add((text) => {
            this.handleKeyFrameChanged(exports.KeyFrameInfoType.LocationY, text);
        });
        this.mInputLocZ.onTextChanged.add((text) => {
            this.handleKeyFrameChanged(exports.KeyFrameInfoType.LocationZ, text);
        });
        // Rot
        this.mInputRotP.onTextChanged.add((text) => {
            this.handleKeyFrameChanged(exports.KeyFrameInfoType.RotationY, text);
        });
        this.mInputRotY.onTextChanged.add((text) => {
            this.handleKeyFrameChanged(exports.KeyFrameInfoType.RotationZ, text);
        });
        this.mInputRotR.onTextChanged.add((text) => {
            this.handleKeyFrameChanged(exports.KeyFrameInfoType.RotationX, text);
        });
        // FOV
        this.mInputFOV.onTextChanged.add((text) => {
            this.handleKeyFrameChanged(exports.KeyFrameInfoType.FOV, text);
        });
        // Del
        this.mBtnDelKeyFrame.onClicked.add(() => {
            CSEditor.instance.delKeyframe(this.selectKeyFramesIndex);
        });
    }
    /**
     * 将按键进行监听，鼠标进入时为选中
     * @param btn 要监听的按钮
     * @param moveUI 需要移动的UI
     */
    addHoverListener(btn, moveUI) {
        btn.onHovered.add(() => {
            if (KeyActionManager.instance.isPress(15 /* KeyAction.HoldUINode */)) {
                return;
            }
            this._moveNode = moveUI;
            // Utils.log("Hover节点", this._moveNode.getName());
        });
        btn.onUnhovered.add(() => {
            if (KeyActionManager.instance.isPress(15 /* KeyAction.HoldUINode */)) {
                return;
            }
            this._moveNode = null;
        });
    }
    /**
     * 更新时间轴绘制
     */
    updateTimeLine() {
        this._timePointUIPool.removeAllNode();
        this._timTextUIPool.removeAllNode();
        // 区总长度减单个刻度条长度
        const spacing = (this.mCanvasTimePoint.size.x) / this._totalTime;
        for (let i = 0; i <= this._totalTime; i++) {
            if (i % 5 === 0) {
                const timePoint = this._timePointUIPool.addNode();
                timePoint.setState(new mw.Vector2(i * spacing - 2, 20), exports.UITimePointState.Long);
                // TimeText
                const timeText = this._timTextUIPool.addNode();
                timeText.setState(new mw.Vector2(i * spacing - (70 / 2), 60), i);
            }
            else {
                const timePoint = this._timePointUIPool.addNode();
                timePoint.setState(new mw.Vector2(i * spacing - 2, 40), exports.UITimePointState.Default);
            }
        }
    }
    /**
     * 更新时间光标到指定时间处
     * @param time 指定时间
     */
    updateCurrentTime(time) {
        this._currentTime = time;
        const x = time / this._totalTime * this.mCanvasTimeLine.size.x - (this.mBtnCurrentTime.size.x / 2);
        this.mBtnCurrentTime.position = (new mw.Vector2(x, this.mBtnCurrentTime.position.y));
    }
    /**
     * 使用关键帧动画更新帧节点显示
     * @param anim 关键帧动画
     */
    updateKeyFrameNode(anim) {
        this.unSelectKeyFrames();
        this._keyFramesUIPool.removeAllNode();
        // 区总长度减单个刻度条长度
        const spacing = (this.mCanvasTimePoint.size.x) / this._totalTime;
        anim.forEach((info, index) => {
            const keyFrames = this._keyFramesUIPool.addNode();
            keyFrames.setState(new mw.Vector2(info.time * spacing - 8, 0), index);
            // 初始帧不做为可移动对象
            if (info.time !== 0) {
                this.addHoverListener(keyFrames.mBtn, keyFrames.uiObject);
                // 使用下表作为name，以便于识别选中的具体关键帧
                keyFrames.uiObject.name = index.toString();
            }
            keyFrames.onSelect.add(() => {
                this.selectKeyFrames(index, false);
            });
        });
    }
    /**
     * 处理关键帧编辑时的值应用
     * @param type
     * @param text
     * @returns
     */
    handleKeyFrameChanged(type, text) {
        if (!this._locCache || !this._rotCache || this.selectKeyFramesIndex < 0)
            return;
        const textNumber = Number(text.trim());
        if (isNaN(textNumber) || textNumber == undefined || textNumber == null) {
            Log.warn("关键帧值设置异常");
            return;
        }
        switch (type) {
            case exports.KeyFrameInfoType.LocationX:
                this._locCache.x = textNumber;
                CSEditor.instance.modifyKeyFramesLoc(this.selectKeyFramesIndex, this._locCache);
                break;
            case exports.KeyFrameInfoType.LocationY:
                this._locCache.y = textNumber;
                CSEditor.instance.modifyKeyFramesLoc(this.selectKeyFramesIndex, this._locCache);
                break;
            case exports.KeyFrameInfoType.LocationZ:
                this._locCache.z = textNumber;
                CSEditor.instance.modifyKeyFramesLoc(this.selectKeyFramesIndex, this._locCache);
                break;
            case exports.KeyFrameInfoType.RotationX:
                this._rotCache.x = textNumber;
                CSEditor.instance.modifyKeyFramesRot(this.selectKeyFramesIndex, this._rotCache);
                break;
            case exports.KeyFrameInfoType.RotationY:
                this._rotCache.y = textNumber;
                CSEditor.instance.modifyKeyFramesRot(this.selectKeyFramesIndex, this._rotCache);
                break;
            case exports.KeyFrameInfoType.RotationZ:
                this._rotCache.z = textNumber;
                CSEditor.instance.modifyKeyFramesRot(this.selectKeyFramesIndex, this._rotCache);
                break;
            case exports.KeyFrameInfoType.FOV:
                CSEditor.instance.modifyKeyFramesFOV(this.selectKeyFramesIndex, textNumber);
                break;
            default:
                Log.err("未更改任何可用值");
                return;
        }
    }
    /**
     * 选中指定索引的帧
     * @param index
     */
    selectKeyFrames(index, isInternal = true) {
        this.selectKeyFramesIndex = index;
        // 外部调用需要设置UI状态
        if (isInternal) {
            this._keyFramesUIPool.selectNode(this._keyFramesUIPool.nodes[index]);
        }
        const info = CSEditor.instance.getKeyFrames(index);
        if (this.mCanvasFramesEdit.visibility !== mw.SlateVisibility.Visible) {
            this.mCanvasFramesEdit.visibility = mw.SlateVisibility.Visible;
        }
        this._locCache.set(info.location);
        this._rotCache.set(info.rotation);
        this.mInputLocX.text = info.location.x.toString();
        this.mInputLocY.text = info.location.y.toString();
        this.mInputLocZ.text = info.location.z.toString();
        this.mInputRotP.text = info.rotation.y.toString();
        this.mInputRotY.text = info.rotation.z.toString();
        this.mInputRotR.text = info.rotation.x.toString();
        this.mInputFOV.text = info.fov.toString();
    }
    /**
     * 取消帧选中
     */
    unSelectKeyFrames() {
        // 将选中用于修改的节点置为空
        if (this.mCanvasFramesEdit.visibility !== mw.SlateVisibility.Hidden) {
            this.mCanvasFramesEdit.visibility = mw.SlateVisibility.Hidden;
        }
        this.selectKeyFramesIndex = -1;
    }
}

/**
 * 关键帧动画播放器（编辑器使用，动画有状态）
 */
class CSEditedPlayer {
    static _instance;
    static get instance() {
        if (!CSEditedPlayer._instance) {
            CSEditedPlayer._instance = new CSEditedPlayer();
        }
        return CSEditedPlayer._instance;
    }
    _uiEdit;
    /** 摄像机锚点（真实相机） */
    _cameraAnchor;
    /** 代理相机 */
    _proxyCamera;
    _currentAnim;
    _currentPlayIndex = 1;
    _currentKeyFrameTime;
    _currentPlayResidueTime;
    _currentPlayProgress;
    handleComplete;
    _isCompleteReductionCameraSetting = false;
    // 当前帧动画是否播放完成
    _isPlaying = false;
    // 是否循环播放
    _isCyclePlay = false;
    /** 插值时临时变量 */
    _cameraAnchorMoveLoc;
    _cameraAnchorMoveRot = new mw.Rotation();
    _cameraAnchorFov = 0;
    // 解锁摄像机延迟变量
    _endSetRotationTime = 0;
    init(cameraAnchor, proxyCamera) {
        this._cameraAnchor = cameraAnchor;
        this._proxyCamera = proxyCamera;
        this._uiEdit = mw.UIService.getUI(UICSEditor);
    }
    setCurrentAnim(anim) {
        this._currentAnim = anim;
    }
    /**
     * 设置当前播放时间 以计算姿态
     * @param currentTime 当前播放总时间
     * @returns
     */
    setCurrentPlayTotalTime(currentTime) {
        // 同步与非同步不同的过滤条件
        if (CSSettings.isCameraSync) {
            if (this._currentAnim.getLength() <= 1 || currentTime > this._currentAnim.getEnd().time) {
                return;
            }
            if (!CameraCG.instance.isFreeCamera) {
                this._isCompleteReductionCameraSetting = true;
                CameraCG.instance.enterFreeCamera();
            }
        }
        else {
            if (this._currentAnim.getLength() <= 1) {
                this._proxyCamera.hide();
                return;
            }
        }
        // 寻找当前时间处于哪个关键帧
        let isFind = false;
        for (let i = 1; i < this._currentAnim.getLength(); i++) {
            if (this._currentAnim.get(i).time > currentTime) {
                this._currentPlayIndex = i;
                isFind = true;
                break;
            }
        }
        // 未找到则置为最大帧（逻辑上仅在代理摄像机时）
        if (!isFind) {
            this._currentPlayIndex = this._currentAnim.getLength() - 1;
            // 计算当前帧播放剩余时间
            this._currentKeyFrameTime = this._currentAnim.getFrameTime(this._currentPlayIndex);
            this._currentPlayResidueTime = 0;
        }
        else {
            // 计算当前帧播放剩余时间
            this._currentKeyFrameTime = this._currentAnim.getFrameTime(this._currentPlayIndex);
            this._currentPlayResidueTime = this._currentAnim.get(this._currentPlayIndex).time - currentTime;
        }
        this.calculationState();
    }
    /**
     * 从当前状态进行播放
     */
    play() {
        if (this._currentAnim.getLength() <= 1) {
            Log.err("动画关键帧缺失");
            return;
        }
        // 当前未处于自由视角则进行切换
        if (!CameraCG.instance.isFreeCamera) {
            this._isCompleteReductionCameraSetting = true;
            CameraCG.instance.enterFreeCamera();
        }
        // 首次播放进行播放状态初始化
        if (!this._currentPlayIndex) {
            this.setCurrentPlayTotalTime(0);
        }
        this._isPlaying = true;
    }
    /**
     * 从头播放动画
     */
    playFromStart() {
        this._currentPlayIndex = 1;
        this._currentKeyFrameTime = this._currentAnim.getFrameTime(this._currentPlayIndex);
        this._currentPlayResidueTime = this._currentKeyFrameTime;
        this.play();
    }
    /**
     * 停止播放
     */
    stop() {
        this._isPlaying = false;
        this._endSetRotationTime = 0.1;
    }
    /**
     * 切换播放与暂停
     */
    switchPlayStop() {
        if (this._isPlaying) {
            this.stop();
        }
        else {
            this.play();
        }
    }
    /** 计算姿态 */
    calculationState() {
        // 计算当前关键帧播放比（0 ~ 1）
        this._currentPlayProgress = 1 - this._currentPlayResidueTime / this._currentKeyFrameTime;
        const lastInfo = this._currentAnim.get(this._currentPlayIndex - 1);
        const nextInfo = this._currentAnim.get(this._currentPlayIndex);
        if (!lastInfo || !nextInfo)
            return;
        // 位置运动插值
        this._cameraAnchorMoveLoc = mw.Vector.lerp(lastInfo.location, nextInfo.location, this._currentPlayProgress);
        // 旋转运动插值
        this._cameraAnchorMoveRot.y = MathUtil.lerp(lastInfo.rotation.y, nextInfo.rotation.y, this._currentPlayProgress);
        this._cameraAnchorMoveRot.z = MathUtil.lerp(lastInfo.rotation.z, nextInfo.rotation.z, this._currentPlayProgress);
        // FOV运动插值
        this._cameraAnchorFov = MathUtil.lerp(lastInfo.fov, nextInfo.fov, this._currentPlayProgress);
        if (CSSettings.isCameraSync) {
            this._cameraAnchor.setLocation(this._cameraAnchorMoveLoc);
            this._cameraAnchor.setRotation(this._cameraAnchorMoveRot);
            this._cameraAnchor.setFOV(this._cameraAnchorFov);
        }
        else {
            this._proxyCamera.setLocation(this._cameraAnchorMoveLoc);
            this._proxyCamera.setRotation(this._cameraAnchorMoveRot);
        }
        this._endSetRotationTime = 0.1;
    }
    setNextFrameInfo() {
        this._currentPlayIndex += 1;
        this._currentKeyFrameTime = this._currentAnim.getFrameTime(this._currentPlayIndex);
        this._currentPlayResidueTime = this._currentKeyFrameTime;
    }
    hasNextFrameInfo() {
        return this._currentPlayIndex + 1 < this._currentAnim.getLength();
    }
    update(dt) {
        // 延迟解锁摄像机
        if (this._endSetRotationTime > 0) {
            this._endSetRotationTime -= dt;
            if (this._endSetRotationTime <= 0) {
                this._cameraAnchor.resetOverrideRotation();
                // 解锁时检测是否需要移动模式还原
                if (this._isCompleteReductionCameraSetting) {
                    this._isCompleteReductionCameraSetting = false;
                    CameraCG.instance.exitFreeCamera();
                }
            }
        }
        // 播放生命周期
        if (!this._isPlaying) {
            return;
        }
        if (this._currentPlayResidueTime > 0) {
            this._currentPlayResidueTime -= dt;
            this.calculationState();
            // 播放时回显UI时间进度
            this._uiEdit.updateCurrentTime(this._currentAnim.get(this._currentPlayIndex).time - this._currentPlayResidueTime);
        }
        else {
            if (this.hasNextFrameInfo()) {
                this.setNextFrameInfo();
            }
            else {
                // 整个帧动画播放完成
                this._isPlaying = false;
                this._cameraAnchor.resetOverrideRotation();
                // 循环播放
                if (this._isCyclePlay) {
                    this.playFromStart();
                }
                // Callback
                if (this.handleComplete) {
                    this.handleComplete();
                    this.handleComplete = null;
                }
                if (this._isCompleteReductionCameraSetting) {
                    this._isCompleteReductionCameraSetting = false;
                    CameraCG.instance.exitFreeCamera();
                }
            }
        }
    }
}

exports.CSDialog_Generate = class CSDialog_Generate extends mw.UIScript {
    mBtnClose = undefined;
    mBtnYes = undefined;
    mBtnNo = undefined;
    mTextContent = undefined;
    /**
    * onStart 之前触发一次
    */
    onAwake() {
    }
};
__decorate([
    UIWidgetBind('MWCanvas_2147482460/mBtnClose')
], exports.CSDialog_Generate.prototype, "mBtnClose", void 0);
__decorate([
    UIWidgetBind('MWCanvas_2147482460/CanvasDialog/CanvasBtnYes/mBtnYes')
], exports.CSDialog_Generate.prototype, "mBtnYes", void 0);
__decorate([
    UIWidgetBind('MWCanvas_2147482460/CanvasDialog/CanvasBtnNo/mBtnNo')
], exports.CSDialog_Generate.prototype, "mBtnNo", void 0);
__decorate([
    UIWidgetBind('MWCanvas_2147482460/CanvasDialog/mTextContent')
], exports.CSDialog_Generate.prototype, "mTextContent", void 0);
exports.CSDialog_Generate = __decorate([
    UIBind('UI/module_cameracg/CSDialog.ui')
], exports.CSDialog_Generate);

/**
 * 通用确认对话框
 */
class UICSDialog extends exports.CSDialog_Generate {
    _handleYes;
    _handleNo;
    onStart() {
        this.mBtnClose.onClicked.add(() => {
            this.hide();
        });
        this.mBtnNo.onClicked.add(() => {
            this.hide();
            if (this._handleNo) {
                this._handleNo();
                this._handleNo = null;
            }
        });
        this.mBtnYes.onClicked.add(() => {
            this.hide();
            if (this._handleYes) {
                this._handleYes();
                this._handleYes = null;
            }
        });
    }
    show(text, onYes, onNo) {
        this.mTextContent.text = text;
        this._handleYes = onYes;
        this._handleNo = onNo;
        mw.UIService.showUI(this);
    }
    hide() {
        mw.UIService.hideUI(this);
    }
}

exports.CSDialogSave_Generate = class CSDialogSave_Generate extends mw.UIScript {
    mBtnClose = undefined;
    mInput = undefined;
    /**
    * onStart 之前触发一次
    */
    onAwake() {
    }
};
__decorate([
    UIWidgetBind('MWCanvas_2147482460/mBtnClose')
], exports.CSDialogSave_Generate.prototype, "mBtnClose", void 0);
__decorate([
    UIWidgetBind('MWCanvas_2147482460/CanvasDialog/mInput')
], exports.CSDialogSave_Generate.prototype, "mInput", void 0);
exports.CSDialogSave_Generate = __decorate([
    UIBind('UI/module_cameracg/CSDialogSave.ui')
], exports.CSDialogSave_Generate);

/**
 * 导入时使用的弹出对话框
 */
class UICSDialogSave extends exports.CSDialogSave_Generate {
    onAwake() {
        this.mBtnClose.onClicked.add(() => {
            this.hide();
        });
    }
    show(jsonStr) {
        this.mInput.text = jsonStr;
        mw.UIService.showUI(this);
    }
    hide() {
        mw.UIService.hideUI(this);
    }
}

/**
 * 编辑器主控制类
 */
class CSEditor {
    static _instance;
    static get instance() {
        if (!CSEditor._instance) {
            CSEditor._instance = new CSEditor();
        }
        return CSEditor._instance;
    }
    /* 是否渲染摄像机路径 */
    isEnablePathRender = true;
    _ui;
    /* 当前选中动画（帧信息组） */
    _currentAnim;
    /* 路径渲染用模型组 */
    _currentPathRenders = [];
    _currentSelectPathRender;
    _cameraAnchor;
    _proxyCamera;
    /* 是否启用相机旋转周数记录 */
    _isRecordCameraCycle = false;
    _cameraCycle = 0;
    _lastCameraRotZ;
    _cameraCycleDifference = 300;
    _storageLoadEvent;
    init(cameraAnchor, proxyCamera) {
        this._cameraAnchor = cameraAnchor;
        this._proxyCamera = proxyCamera;
        this._ui = mw.UIService.getUI(UICSEditor);
        this.initKeyboardKeys();
        this._currentAnim = new KeyFrame();
        CSEditedPlayer.instance.setCurrentAnim(this._currentAnim);
        // 暂存数据读取
        this._storageLoadEvent = Event.addServerListener(CSConfig.EVENT_TEMP_STORAGE_LOAD_RESPONSE, (...params) => {
            if (params && params.length == 1 && params[0]) {
                const anim = KeyFrame.deserialize(params[0]);
                if (anim) {
                    this._currentAnim = anim;
                    CSEditedPlayer.instance.setCurrentAnim(this._currentAnim);
                    this.updatePathRender();
                    this._ui.updateKeyFrameNode(this._currentAnim);
                }
            }
            else {
                Log.warn("数据读取失败");
            }
        });
        Event.dispatchToServer(CSConfig.EVENT_TEMP_STORAGE_LOAD);
        // 延迟显示编辑器UI 防止被覆盖
        setTimeout(() => {
            this._ui.show();
        }, 50);
    }
    destroy() {
        for (const go of this._currentPathRenders) {
            go.destroy();
        }
        this._currentPathRenders.length = 0;
        this._ui?.destroy();
        this._storageLoadEvent?.disconnect();
        this._storageLoadEvent = null;
    }
    update(dt) {
        if (this._isRecordCameraCycle) {
            let difference = this._cameraAnchor.camera.worldTransform.clone().rotation.z - this._lastCameraRotZ;
            if (difference > this._cameraCycleDifference) {
                this._cameraCycle -= 1;
            }
            else if (difference < -this._cameraCycleDifference) {
                this._cameraCycle += 1;
            }
            this._lastCameraRotZ = this._cameraAnchor.camera.worldTransform.clone().rotation.z;
        }
    }
    /* 初始化键盘按键映射 */
    initKeyboardKeys() {
        // 响应关键帧记录
        InputUtil.onKeyDown(CSConfig.KEY_ACTION_MAP.get(6 /* KeyAction.KeyFrame */), () => {
            this.recordKeyframe();
        });
        // 响应删除选中的关键帧
        InputUtil.onKeyDown(CSConfig.KEY_ACTION_MAP.get(7 /* KeyAction.DelKeyFrame */), () => {
            this.delKeyframe(this._ui.selectKeyFramesIndex);
        });
        // 响应播放
        InputUtil.onKeyDown(CSConfig.KEY_ACTION_MAP.get(10 /* KeyAction.PlayKeyFrames */), () => {
            CSEditedPlayer.instance.play();
        });
        // 响应从头播放
        InputUtil.onKeyDown(CSConfig.KEY_ACTION_MAP.get(11 /* KeyAction.PlayKeyFramesFromStart */), () => {
            CSEditedPlayer.instance.playFromStart();
        });
        // 响应停止播放
        InputUtil.onKeyDown(CSConfig.KEY_ACTION_MAP.get(12 /* KeyAction.StopKeyFrames */), () => {
            CSEditedPlayer.instance.stop();
        });
        // 响应回到最末帧
        InputUtil.onKeyDown(CSConfig.KEY_ACTION_MAP.get(9 /* KeyAction.Back2LastFrame */), () => {
            if (this._currentAnim.getLength() <= 0) {
                return;
            }
            // 当前未处于自由视角则进行切换
            if (!CameraCG.instance.isFreeCamera) {
                CameraCG.instance.enterFreeCamera();
            }
            if (CSSettings.isCameraSync) {
                this._cameraAnchor.setLocation(this._currentAnim.getEnd().location.clone());
                this._cameraAnchor.setRotation(this._currentAnim.getEnd().rotation);
            }
            else {
                this._proxyCamera.setLocation(this._currentAnim.getEnd().location.clone());
                this._proxyCamera.setRotation(this._currentAnim.getEnd().rotation);
            }
            // 重解算周数
            let cycle = Math.floor(this._currentAnim.getEnd().rotation.z / 360);
            if (cycle < 0) {
                cycle += 1;
            }
            this._cameraCycle = cycle;
            // 本次游戏循环后释放SetRotation，角度旋转参才能被正确的应用
            setTimeout(() => {
                this._cameraAnchor.resetOverrideRotation();
            }, 1);
        });
        // 响应保存
        InputUtil.onKeyDown(CSConfig.KEY_ACTION_MAP.get(13 /* KeyAction.SaveAnim */), () => {
            this.saveCurrentAnim();
        });
        // 响应清空当前动画
        InputUtil.onKeyDown(CSConfig.KEY_ACTION_MAP.get(14 /* KeyAction.ClearAnim */), () => {
            this.clearCurrentAnim();
        });
    }
    /* 在世界中绘制路径显示模型 */
    updatePathRender() {
        for (const go of this._currentPathRenders) {
            GameObjPool.despawn(go);
        }
        this._currentPathRenders.length = 0;
        // 节点判空
        if (this._currentAnim.getLength() <= 0) {
            return;
        }
        // 绘制初始点
        const pointGo = GoPool.getInstance().spawn(Assets.MESH_CONES);
        pointGo.setMaterial(Assets.MATERIAL_TRANSPARENT);
        pointGo.createMaterialInstance(0);
        pointGo.getMaterialInstance()[0].setVectorParameterValue("MW_Main_Color", mw.LinearColor.blue);
        pointGo.getMaterialInstance()[0].setScalarParameterValue("MW_Transparency", 0.8);
        pointGo.worldTransform.position = this._currentAnim.get(0).location.clone();
        pointGo.worldTransform.scale = new mw.Vector(0.3, 0.3, 0.2);
        pointGo.worldTransform.rotation = this._currentAnim.get(0).rotation.clone().add(new mw.Rotation(0, 90, 0));
        this._currentPathRenders.push(pointGo);
        // 绘制后续点
        for (let i = 1; i < this._currentAnim.getLength(); i++) {
            this._currentAnim.get(i);
            const frame1 = this._currentAnim.get(i - 1);
            const frame2 = this._currentAnim.get(i);
            // 关键帧点显示对象
            const pointGo = GoPool.getInstance().spawn(Assets.MESH_CONES);
            pointGo.setMaterial(Assets.MATERIAL_TRANSPARENT);
            pointGo.createMaterialInstance(0);
            pointGo.getMaterialInstance()[0].setVectorParameterValue("MW_Main_Color", mw.LinearColor.green);
            pointGo.getMaterialInstance()[0].setScalarParameterValue("MW_Transparency", 0.8);
            pointGo.worldTransform.position = frame2.location.clone();
            pointGo.worldTransform.scale = new mw.Vector(0.3, 0.3, 0.2);
            pointGo.worldTransform.rotation = frame2.rotation.clone().add(new mw.Rotation(0, 90, 0));
            this._currentPathRenders.push(pointGo);
            // 路径显示对象
            const lineGo = GoPool.getInstance().spawn(Assets.MESH_BLOCK);
            lineGo.setMaterial(Assets.MATERIAL_TRANSPARENT);
            lineGo.createMaterialInstance(0);
            lineGo.getMaterialInstance()[0].setVectorParameterValue("MW_Main_Color", mw.LinearColor.red);
            pointGo.getMaterialInstance()[0].setScalarParameterValue("MW_Transparency", 0.8);
            lineGo.worldTransform.position = mw.Vector.lerp(frame1.location, frame2.location, 0.5);
            lineGo.worldTransform.scale = new mw.Vector(this._currentAnim.getLocationDifference(i - 1, i) / 100, 0.02, 0.02);
            lineGo.worldTransform.rotation = mw.Rotation.fromVector(mw.Vector.subtract(frame2.location, frame1.location), lineGo.worldTransform.rotation);
            this._currentPathRenders.push(lineGo);
        }
    }
    /**
     * 时间轴增减变动合法性检测
     */
    checkUpdateTimeline(totalTime) {
        if (this._currentAnim.getLength() > 0 && this._currentAnim.getEnd().time > totalTime) {
            Log.err("动画长度大于时间轴长度");
            return false;
        }
        return true;
    }
    /* 时间轴增减变动时调用 */
    updateTimeline() {
        this._ui.updateKeyFrameNode(this._currentAnim);
    }
    /* 记录关键帧 */
    recordKeyframe() {
        // 非自由视角不可记录关键帧
        if (!CameraCG.instance.isFreeCamera) {
            Log.err("非自由视角不可记录关键帧");
            return;
        }
        const tran = this._cameraAnchor.camera.worldTransform.clone();
        let info;
        // 初始帧
        if (this._currentAnim.getLength() === 0) {
            info = new KeyFrameInfo(0, tran.position, tran.rotation, Number(this._cameraAnchor.camera.fov.toFixed(2)));
        }
        else {
            tran.rotation.z += this._cameraCycle * 360;
            info = new KeyFrameInfo(this._ui.currentTime, tran.position, tran.rotation, Number(this._cameraAnchor.camera.fov.toFixed(2)));
        }
        // 插入帧成功
        if (info && this._currentAnim.push(info)) {
            this.updatePathRender();
            this._ui.updateKeyFrameNode(this._currentAnim);
            this._ui.selectKeyFrames(this._currentAnim.indexOf(info));
            Event.dispatchToServer(CSConfig.EVENT_TEMP_STORAGE_SAVE, JSON.stringify(this._currentAnim));
            // 首个关键帧记录时重置并启用旋转周数记录
            if (!this._isRecordCameraCycle && this._currentAnim.getLength() > 0) {
                this._cameraCycle = 0;
                this._lastCameraRotZ = this._cameraAnchor.camera.worldTransform.rotation.z;
                this._isRecordCameraCycle = true;
            }
        }
    }
    /* 清空当前动画 */
    delKeyframe(index) {
        if (index <= 0) {
            Log.err("删除关键帧无效或为首个关键帧");
            return;
        }
        this._currentAnim.del(index);
        this.updatePathRender();
        this._ui.updateKeyFrameNode(this._currentAnim);
        Event.dispatchToServer(CSConfig.EVENT_TEMP_STORAGE_SAVE, JSON.stringify(this._currentAnim));
        // 重计算代理摄像机位置
        if (!CSSettings.isCameraSync) {
            CSEditedPlayer.instance.setCurrentPlayTotalTime(this._ui.currentTime);
        }
    }
    /* 清空当前动画 */
    clearCurrentAnim() {
        CSEditedPlayer.instance.stop();
        mw.UIService.getUI(UICSDialog).show("确定要清空所有关键帧吗？", () => {
            this._currentAnim.clear();
            this.updatePathRender();
            this._ui.updateKeyFrameNode(this._currentAnim);
            Event.dispatchToServer(CSConfig.EVENT_TEMP_STORAGE_SAVE, JSON.stringify(this._currentAnim));
            // 重计算代理摄像机位置
            if (!CSSettings.isCameraSync) {
                CSEditedPlayer.instance.setCurrentPlayTotalTime(this._ui.currentTime);
            }
            this._isRecordCameraCycle = false;
        });
    }
    getKeyFrames(index) {
        return this._currentAnim.get(index);
    }
    /**
     * 修改指定关键帧时间
     * @param index 需要修改的关键帧序号
     * @param time 修改后的时间
     */
    modifyKeyFramesTime(index, time) {
        if (this._currentAnim.get(index).time === time)
            return;
        const newIndex = this._currentAnim.modifyTime(index, time);
        this._ui.updateKeyFrameNode(this._currentAnim);
        this.updatePathRender();
        Event.dispatchToServer(CSConfig.EVENT_TEMP_STORAGE_SAVE, JSON.stringify(this._currentAnim));
        // 重计算代理摄像机位置
        if (!CSSettings.isCameraSync) {
            CSEditedPlayer.instance.setCurrentPlayTotalTime(this._ui.currentTime);
        }
        return newIndex;
    }
    modifyKeyFramesLoc(index, loc) {
        if (this._currentAnim.get(index).location.equals(loc))
            return;
        this._currentAnim.modifyLoc(index, loc);
        this.updatePathRender();
        Event.dispatchToServer(CSConfig.EVENT_TEMP_STORAGE_SAVE, JSON.stringify(this._currentAnim));
        // 重计算代理摄像机/锚点位置
        if (CSSettings.isCameraSync) {
            CSEditedPlayer.instance.calculationState();
        }
        else {
            CSEditedPlayer.instance.setCurrentPlayTotalTime(this._ui.currentTime);
        }
    }
    modifyKeyFramesRot(index, rot) {
        if (this._currentAnim.get(index).rotation.equals(rot))
            return;
        this._currentAnim.modifyRot(index, rot);
        this.updatePathRender();
        Event.dispatchToServer(CSConfig.EVENT_TEMP_STORAGE_SAVE, JSON.stringify(this._currentAnim));
        // 重计算代理摄像机/锚点旋转
        if (CSSettings.isCameraSync) {
            CSEditedPlayer.instance.calculationState();
        }
        else {
            CSEditedPlayer.instance.setCurrentPlayTotalTime(this._ui.currentTime);
        }
    }
    modifyKeyFramesFOV(index, fov) {
        if (this._currentAnim.get(index).fov === fov)
            return;
        this._currentAnim.modifyFOV(index, fov);
        Event.dispatchToServer(CSConfig.EVENT_TEMP_STORAGE_SAVE, JSON.stringify(this._currentAnim));
        // 重计算锚点摄像机FOV
        if (CSSettings.isCameraSync) {
            CSEditedPlayer.instance.calculationState();
        }
    }
    /* 切换是否进行相机同步的设置 */
    switchCameraSync() {
        CSSettings.isCameraSync = !CSSettings.isCameraSync;
        if (CSSettings.isCameraSync) {
            this._proxyCamera.hide();
        }
        else {
            // 动画非空则显示代理相机模型
            if (this._currentAnim.getLength() > 1) {
                this._proxyCamera.show();
                CSEditedPlayer.instance.setCurrentPlayTotalTime(this._ui.currentTime);
            }
        }
    }
    /**
     * 通过Json字符串载入动画
     * @param animJsonStr 动画Json字符串
     * @returns 是否成功
     */
    loadAnim(animJsonStr) {
        try {
            const strReplace = animJsonStr.replace(/\\\"/g, "\"");
            const anim = KeyFrame.deserialize(strReplace);
            if (anim) {
                this._currentAnim = anim;
                CSEditedPlayer.instance.setCurrentAnim(this._currentAnim);
                this.updatePathRender();
                this._ui.updateKeyFrameNode(this._currentAnim);
                // 重计算代理摄像机位置
                if (!CSSettings.isCameraSync) {
                    CSEditedPlayer.instance.setCurrentPlayTotalTime(this._ui.currentTime);
                }
                return true;
            }
            return false;
        }
        catch (error) {
            Log.err("反序列化对象失败", error);
            return false;
        }
    }
    /* 保存当前动画数据 */
    saveCurrentAnim() {
        const text = JSON.stringify(this._currentAnim).replace(/\"/g, "\\\"");
        mw.UIService.getUI(UICSDialogSave).show(text);
    }
    /* 重置摄像机FOV */
    resetCameraFOV() {
        const fov = CameraCG.instance.originCamera ? CameraCG.instance.originCamera.fov : 90;
        this._cameraAnchor.setFOV(fov);
    }
}

class MyQuaternion {
    w = 0;
    x = 0;
    y = 0;
    z = 0;
    /** 模长 */
    get length() {
        return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
    }
    /** 共轭 */
    get conjugated() {
        return new MyQuaternion(this.w, -this.x, -this.y, -this.z);
    }
    /** 四元数的逆（共轭/模长^2）*/
    get inverted() {
        const length2 = Math.pow(this.length, 2);
        const conjugated = this.conjugated;
        return new MyQuaternion(conjugated.w / length2, conjugated.x / length2, conjugated.y / length2, conjugated.z / length2);
    }
    constructor(w, x, y, z) {
        if (w) {
            this.w = w;
        }
        if (x) {
            this.x = x;
        }
        if (y) {
            this.y = y;
        }
        if (z) {
            this.z = z;
        }
    }
    /**
     * 通过欧拉角设置四元数值
     */
    setEulerAngles(euler) {
        this.euler2quat(euler.x, euler.y, euler.z);
    }
    euler2quat(roll, pitch, yaw) {
        // 度数到半径
        yaw = yaw * Math.PI / 180;
        // 引擎中实际坐标方向与参考公式坐标修正
        pitch = -pitch * Math.PI / 180;
        roll = -roll * Math.PI / 180;
        // 各角度函数的缩写
        const cy = Math.cos(yaw * 0.5);
        const sy = Math.sin(yaw * 0.5);
        const cp = Math.cos(pitch * 0.5);
        const sp = Math.sin(pitch * 0.5);
        const cr = Math.cos(roll * 0.5);
        const sr = Math.sin(roll * 0.5);
        this.w = cy * cp * cr + sy * sp * sr;
        this.x = cy * cp * sr - sy * sp * cr;
        this.y = sy * cp * sr + cy * sp * cr;
        this.z = sy * cp * cr - cy * sp * sr;
    }
    /**
     * 四元数乘向量
     * @param v
     * @param q
     * @param out 接收值，没有则会创建
     * @returns 相乘结果向量
     */
    static multiplyVector(v, q, out) {
        if (!out) {
            out = new mw.Vector();
        }
        // 扩充向量
        const vExp = new MyQuaternion(0, v.x, v.y, v.z);
        // q * v = (q) * (v扩充) * (q的逆)
        const result = this.multiply(this.multiply(q, vExp), q.inverted);
        out.x = result.x;
        out.y = result.y;
        out.z = result.z;
        return out;
    }
    /**
     * 四元数叉乘
     * @param q1
     * @param q2
     * @param out 接收值，没有则会创建
     */
    static multiply(q1, q2, out) {
        if (!out) {
            out = new MyQuaternion();
        }
        out.w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;
        out.x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;
        out.y = q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z;
        out.z = q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x;
        return out;
    }
    toString() {
        return `{x:${this.x},y:${this.y},z:${this.z},w:${this.w}}`;
    }
}

/**
 * 关键帧动画播放器（完整播放，动画无状态，外部使用）
 */
class CSPlayer {
    static _instance;
    static get instance() {
        if (!CSPlayer._instance) {
            CSPlayer._instance = new CSPlayer();
        }
        return CSPlayer._instance;
    }
    _cameraAnchor;
    _currentAnim;
    _currentPlayIndex;
    _currentKeyFrameTime;
    _currentPlayResidueTime;
    _currentPlayProgress;
    handleComplete;
    _isCompleteReductionCameraSetting = true;
    VECTOR_ZERO = mw.Vector.zero;
    /** 当前帧动画是否播放完成 */
    _isPlayComplete = true;
    _cameraAnchorMoveLoc;
    _cameraAnchorMoveRot = new mw.Rotation;
    _cameraAnchorFov = 0;
    // private _cameraAnchorMoveQuat: mw.Quaternion;
    _offsetLoc;
    _offsetRot;
    /** 应用到摄像机时的偏移量 */
    _offsetMQua = new MyQuaternion();
    init(cameraAnchor) {
        this._cameraAnchor = cameraAnchor;
    }
    /**
     * 带偏移值的完整播放动画
     * @param offsetLoc
     * @param offsetRot
     * @param anim
     * @param isReductionCamera
     * @param handleComplete
     */
    playOnOffset(offsetLoc, offsetRot, anim, isReductionCamera, handleComplete) {
        // 无旋转偏移时的Loc
        this._offsetLoc = offsetLoc.clone();
        this._offsetRot = offsetRot.clone();
        this._offsetMQua.setEulerAngles(new mw.Vector(this._offsetRot.x, this._offsetRot.y, this._offsetRot.z));
        this.play(anim, isReductionCamera, handleComplete);
    }
    /**
     * 完整播放动画
     * @param anim
     * @param isReductionCamera
     * @param handleComplete
     */
    play(anim, isReductionCamera, handleComplete) {
        if (anim.getLength() <= 1) {
            Log.err("动画关键帧缺失");
            return;
        }
        this._isCompleteReductionCameraSetting = isReductionCamera;
        // 当前未处于自由视角则进行切换
        if (!CameraCG.instance.isFreeCamera) {
            CameraCG.instance.enterFreeCamera();
        }
        this.handleComplete = handleComplete;
        this._currentAnim = anim;
        this._currentPlayIndex = 1;
        // 将描点移动到初始帧位置
        this._cameraAnchor.setLocation(this._currentAnim.get(0).location);
        this._cameraAnchorMoveLoc = this._cameraAnchor.getLocation();
        this._currentKeyFrameTime = this._currentAnim.getFrameTime(this._currentPlayIndex);
        this._currentPlayResidueTime = this._currentKeyFrameTime;
        this._isPlayComplete = false;
    }
    stop() {
        this._isPlayComplete = true;
        this._offsetLoc = null;
        this._offsetRot = null;
        if (this._isCompleteReductionCameraSetting) {
            // this._cameraAnchor.resetOverrideRotation();
            CameraCG.instance.exitFreeCamera();
        }
    }
    setNextFrameInfo() {
        this._currentPlayIndex += 1;
        this._currentKeyFrameTime = this._currentAnim.getFrameTime(this._currentPlayIndex);
        this._currentPlayResidueTime = this._currentKeyFrameTime;
    }
    hasNextFrameInfo() {
        return this._currentPlayIndex + 1 < this._currentAnim.getLength();
    }
    update(dt) {
        if (this._isPlayComplete) {
            return;
        }
        if (this._currentPlayResidueTime > 0) {
            this._currentPlayResidueTime -= dt;
            // 计算当前关键帧播放比（0 ~ 1）
            this._currentPlayProgress = 1 - this._currentPlayResidueTime / this._currentKeyFrameTime;
            // 位置运动插值
            mw.Vector.lerp(this._currentAnim.get(this._currentPlayIndex - 1).location, this._currentAnim.get(this._currentPlayIndex).location, this._currentPlayProgress, this._cameraAnchorMoveLoc);
            // 通过旋转偏移解算正确位置
            if (this._offsetRot) {
                let dir = mw.Vector.subtract(this._cameraAnchorMoveLoc, this.VECTOR_ZERO);
                MyQuaternion.multiplyVector(dir, this._offsetMQua, this._cameraAnchorMoveLoc);
            }
            // 位置偏移
            if (this._offsetLoc) {
                this._cameraAnchorMoveLoc.add(this._offsetLoc);
            }
            this._cameraAnchor.setLocation(this._cameraAnchorMoveLoc);
            // 旋转运动插值
            this._cameraAnchorMoveRot.y = MathUtil.lerp(this._currentAnim.get(this._currentPlayIndex - 1).rotation.y, this._currentAnim.get(this._currentPlayIndex).rotation.y, this._currentPlayProgress);
            this._cameraAnchorMoveRot.z = MathUtil.lerp(this._currentAnim.get(this._currentPlayIndex - 1).rotation.z, this._currentAnim.get(this._currentPlayIndex).rotation.z, this._currentPlayProgress);
            // 旋转偏移
            if (this._offsetRot) {
                // 不再对Z以外的轴进行旋转修正（会造成视野倾斜导致恢复摄像机异常）
                // this._cameraAnchorMoveRot.addition(this._offsetRot, this._cameraAnchorMoveRot);
                this._cameraAnchorMoveRot.z += this._offsetRot.z;
            }
            this._cameraAnchor.setRotation(this._cameraAnchorMoveRot);
            // FOV运动插值
            this._cameraAnchorFov = MathUtil.lerp(this._currentAnim.get(this._currentPlayIndex - 1).fov, this._currentAnim.get(this._currentPlayIndex).fov, this._currentPlayProgress);
            this._cameraAnchor.setFOV(this._cameraAnchorFov);
        }
        else {
            if (this.hasNextFrameInfo()) {
                this.setNextFrameInfo();
            }
            else {
                // 整个帧动画播放完成
                this._isPlayComplete = true;
                this._offsetLoc = null;
                this._offsetRot = null;
                // Callback
                if (this.handleComplete) {
                    this.handleComplete();
                    this.handleComplete = null;
                }
                if (this._isCompleteReductionCameraSetting) {
                    // this._cameraAnchor.resetOverrideRotation();
                    CameraCG.instance.exitFreeCamera();
                }
            }
        }
    }
}

/**
 * 代理摄像机
 * 非摄像机同步模式下使用的代替显示对象
 */
class CameraProxy {
    isShow = false;
    _anchorObj;
    constructor() {
        this._anchorObj = GoPool.getInstance().spawn(Assets.MESH_CONES, GameObjPoolSourceType.Asset);
        this._anchorObj.createMaterialInstance(0);
        this._anchorObj.getMaterialInstance()[0].setVectorParameterValue("MW_MainColor", mw.LinearColor.yellow);
        this._anchorObj.setVisibility(mw.PropertyStatus.Off);
        this._anchorObj.worldTransform.scale = new mw.Vector(0.4, 0.4, 0.3);
    }
    getGameObject() {
        return this._anchorObj;
    }
    getLocation() {
        return this._anchorObj.worldTransform.position.clone();
    }
    setLocation(location) {
        if (!this.isShow) {
            this._anchorObj.setVisibility(mw.PropertyStatus.On);
            this.isShow = true;
        }
        this._anchorObj.worldTransform.position = location;
    }
    setRotation(rotation) {
        if (!this.isShow) {
            this._anchorObj.setVisibility(mw.PropertyStatus.On);
            this.isShow = true;
        }
        this._anchorObj.worldTransform.rotation = rotation.clone().add(new mw.Rotation(0, 90, 0));
    }
    show() {
        this._anchorObj.setVisibility(mw.PropertyStatus.On);
        this.isShow = true;
    }
    hide() {
        this._anchorObj.setVisibility(mw.PropertyStatus.Off);
        this.isShow = false;
    }
    destroy() {
        this._anchorObj.destroy();
    }
}

/**
 * 需要的预加载资源
 */
const Assets = {
    MESH_BLOCK: "21588",
    MESH_CONES: "21586",
    MESH_BALL: "21586",
    MATERIAL_TRANSPARENT: "61010"
};
/**
 * 对外主控类
 */
class CameraCG {
    static _instance = new CameraCG();
    static get instance() {
        if (!CameraCG._instance) {
            CameraCG._instance = new CameraCG();
        }
        return CameraCG._instance;
    }
    /* 模块是否准备完成 */
    isReady = false;
    /* 模块是正在初始化 */
    initializing = false;
    /* 是否处于自由视角状态 */
    isFreeCamera = false;
    /* 是否首次使用自由视角 */
    _isFirstFreeCamera = true;
    /* 摄像机锚点对象 */
    _cameraAnchor;
    /* 代理摄像机对象 */
    _cameraProxy;
    /* 保有当前角色对象 */
    _character;
    /* 保有当前摄像机系统 */
    originCamera;
    /* 用户摄像机设置备份 */
    // public backupCameraSetting: CameraData;
    /* 临时存储事件 */
    _storageSaveEvent;
    _storageLoadEvent;
    constructor() {
        if (SystemUtil.isPIE && SystemUtil.isServer()) {
            this._storageSaveEvent = Event.addClientListener(CSConfig.EVENT_TEMP_STORAGE_SAVE, (player, ...params) => {
                if (params && params.length == 1) {
                    DataStorage.asyncSetData(CSConfig.TEMP_STORAGE_KEY, params[0]);
                }
                else {
                    Log.warn("数据不符，存储失败");
                }
            });
            this._storageLoadEvent = Event.addClientListener(CSConfig.EVENT_TEMP_STORAGE_LOAD, (player, ...params) => {
                DataStorage.asyncGetData(CSConfig.TEMP_STORAGE_KEY).then((value) => {
                    Event.dispatchToClient(player, CSConfig.EVENT_TEMP_STORAGE_LOAD_RESPONSE, value);
                }).catch((reason) => {
                    Log.err("临时数据读取异常", reason);
                    Event.dispatchToClient(player, CSConfig.EVENT_TEMP_STORAGE_LOAD_RESPONSE, null);
                });
            });
            Log.info("数据存储事件创建");
        }
        if (SystemUtil.isPIE && SystemUtil.isClient()) {
            // Init Keyboard Keys
            InputUtil.onKeyDown(CSConfig.KEY_ACTION_MAP.get(16 /* KeyAction.OpenEditor */), () => {
                this.openEditor();
            });
            InputUtil.onKeyDown(CSConfig.KEY_ACTION_MAP.get(17 /* KeyAction.CloseEditor */), () => {
                this.closeEditor();
            });
            Log.info("预实例化完成");
        }
    }
    async init() {
        if (this.isReady)
            return true;
        if (this.initializing)
            return false;
        this.initializing = true;
        // 预加载资源
        for (const key in Assets) {
            if (Assets.hasOwnProperty(key)) {
                const element = Assets[key];
                console.log("key", key, element);
                await AssetUtil.asyncDownloadAsset(element);
            }
        }
        // update
        TimeUtil.onEnterFrame.add(this.update, this);
        this._character = Player.localPlayer.character;
        // 摄像机系统变量初始化
        if (!this.originCamera) {
            this.originCamera = Camera.currentCamera;
            // 备份的摄像机设置
            // this.backupCameraSetting = ModifiedCameraSystem.getCurrentSettings();
        }
        // 在锚点需求游戏对象下载完成后，初始化锚点与外部播放器
        this._cameraAnchor = new CameraAnchor();
        // 初始外部化动画播放器
        CSPlayer.instance.init(this._cameraAnchor);
        // 自由视角功能初始化
        InputUtil.onKeyDown(CSConfig.KEY_ACTION_MAP.get(8 /* KeyAction.ChangeView */), () => {
            if (this.isFreeCamera) {
                this.exitFreeCamera();
            }
            else {
                // 首次切换初始化锚点
                if (this._isFirstFreeCamera) {
                    const characterLoc = this._character.worldTransform.position.clone();
                    characterLoc.z += 100;
                    this._cameraAnchor.setLocation(characterLoc);
                    this._isFirstFreeCamera = false;
                }
                this.enterFreeCamera();
            }
        });
        KeyActionManager.instance.init();
        this.initializing = false;
        this.isReady = true;
        return true;
    }
    destroy() {
        TimeUtil.onEnterFrame.remove(this.update, this);
        this._storageSaveEvent?.disconnect();
        this._storageLoadEvent?.disconnect();
        this._cameraAnchor?.destroy();
        this._cameraProxy?.destroy();
        CSEditor.instance?.destroy();
    }
    update(dt) {
        // 对外使用关键帧动画播放器生命周期
        CSPlayer.instance?.update(dt);
        // 自由视角锚点生命周期，用于监听移动
        this._cameraAnchor?.update(dt);
        // 编辑器相关生命周期
        CSEditor.instance?.update(dt);
        CSEditedPlayer.instance?.update(dt);
    }
    //#region 提供API
    /**
     * 启用编辑器
     */
    async openEditor() {
        if (!await this.init())
            return;
        this._cameraProxy = new CameraProxy();
        CSEditedPlayer.instance.init(this._cameraAnchor, this._cameraProxy);
        CSEditor.instance.init(this._cameraAnchor, this._cameraProxy);
    }
    /**
     * 关闭编辑器
     */
    async closeEditor() {
        if (!await this.init())
            return;
        CSEditor.instance.destroy();
    }
    /**
     * 播放动画
     * @param jsonStr 动画Json文本
     * @param handleComplete 完成回调
     * @param isReduction 播放完成是否恢复摄像机
     */
    async play(jsonStr, handleComplete, isReduction = true) {
        if (!await this.init())
            return;
        try {
            // 反序列化并播放对象
            const anim = KeyFrame.deserialize(jsonStr);
            if (anim) {
                CSPlayer.instance.play(anim, isReduction, handleComplete);
            }
        }
        catch (error) {
            Log.err("摄像机轨迹动画播放失败", error);
        }
    }
    /**
     * 将游戏对象位置作为播放偏移点进行动画播放
     * @param obj 作为偏移点的对象
     * @param jsonStr 动画Json文本
     * @param handleComplete 完成回调
     * @param isReduction 播放完成是否恢复摄像机
     */
    async playOnGameObject(obj, jsonStr, handleComplete, isReduction = true) {
        this.playOnOffset(obj.worldTransform.position, obj.worldTransform.rotation, jsonStr, handleComplete, isReduction);
    }
    /**
     * 带偏移点进行播放
     * @param offsetLoc 坐标偏移
     * @param offsetRot 旋转偏移
     * @param jsonStr 动画Json文本
     * @param handleComplete 完成回调
     * @param isReduction 播放完成是否恢复摄像机
     */
    async playOnOffset(offsetLoc, offsetRot, jsonStr, handleComplete, isReduction = true) {
        if (!await this.init())
            return;
        try {
            // 反序列化并播放对象
            const anim = KeyFrame.deserialize(jsonStr);
            if (anim) {
                CSPlayer.instance.playOnOffset(offsetLoc, offsetRot, anim, isReduction, handleComplete);
            }
        }
        catch (error) {
            Log.err("摄像机轨迹动画播放失败", error);
        }
    }
    /**
     * 停止播放当前动画
     */
    async stop() {
        if (!await this.init())
            return;
        CSPlayer.instance.stop();
    }
    /**
     * 进入自由视角（但暂未提供触屏控制方式）
     */
    async enterFreeCamera() {
        if (!await this.init())
            return;
        this.isFreeCamera = true;
        // 旧方案 绑定当前摄像机
        // this._cameraSys.parent = this._cameraAnchor.getAnchorGameObject();
        // this._cameraSys.springArm.localTransform = Transform.identity;
        Camera.switch(this._cameraAnchor.camera, 0);
        this.originCamera.springArm.useControllerRotation = false;
        this._cameraAnchor.camera.springArm.useControllerRotation = true;
    }
    /**
     * 退出自由视角，还原摄像机设置
     */
    async exitFreeCamera() {
        if (!await this.init())
            return;
        this.isFreeCamera = false;
        // 旧方案 绑定当前摄像机
        // this._cameraSys.parent = Player.localPlayer.character;
        // this._cameraSys.springArm.localTransform = Transform.identity;
        Camera.switch(this.originCamera, 0);
        this._cameraAnchor.camera.springArm.useControllerRotation = false;
        this.originCamera.springArm.useControllerRotation = true;
    }
}

/**
 * 插值器
 */
class Interpolator {
}

/**
 * 三次样条插值器 Vector2
 * 需线性扫描X轴作为t值
 */
class CubicInterpolator2 extends Interpolator {
    points;
    segments;
    h;
    interpolate(t) {
        if (t < this.points[0].x) {
            return null;
        }
        else if (t > this.points[this.points.length - 1].x) {
            return null;
        }
        const i = this.findIndex(t);
        const dx = t - this.points[i].x;
        const segment = this.segments[i];
        const result = segment.a + segment.b * dx + segment.c * dx ** 2.0 + segment.d * dx ** 3.0;
        return result;
    }
    /** 计算每一段路径的参数组 */
    reCompute(points) {
        // 赋值与合法性校验
        if (points) {
            this.points = points;
        }
        else if (this.points) {
            points = this.points;
        }
        else {
            console.error("[CubicInterpolator2] No points to compute.");
            return;
        }
        this.h = new Array(points.length - 1);
        this.segments = new Array(points.length - 1);
        // Compute h values
        for (let i = 0; i < this.h.length; i++) {
            this.h[i] = points[i + 1].x - points[i].x;
        }
        // Compute a values
        const a = new Array(points.length);
        for (let i = 1; i < a.length - 1; i++) {
            a[i] =
                (3 / this.h[i]) * (points[i + 1].y - points[i].y) -
                    (3 / this.h[i - 1]) * (points[i].y - points[i - 1].y);
        }
        // Compute segments
        const l = new Array(points.length - 1);
        const mu = new Array(points.length - 1);
        const z = new Array(points.length);
        l[0] = 1;
        mu[0] = 0;
        z[0] = 0;
        for (let i = 1; i < this.segments.length; i++) {
            l[i] = 2 * (points[i + 1].x - points[i - 1].x) - this.h[i - 1] * mu[i - 1];
            mu[i] = this.h[i] / l[i];
            z[i] =
                (a[i] - this.h[i - 1] * z[i - 1]) /
                    l[i];
        }
        l[this.segments.length] = 1;
        z[this.segments.length] = 0;
        this.segments[this.segments.length - 1] = { a: 0, b: 0, c: 0, d: 0 };
        for (let i = this.segments.length - 1; i >= 0; i--) {
            this.segments[i] = {
                a: points[i].y,
                b: (points[i + 1].y - points[i].y) / this.h[i] - (this.h[i] * (z[i + 1] + 2 * z[i])) / 3,
                c: z[i],
                d: (z[i + 1] - z[i]) / (3 * this.h[i]),
            };
        }
        return this;
    }
    findIndex(x) {
        for (let i = 0; i < this.points.length; i++) {
            if (this.points[i].x - x > 0) {
                return i - 1;
            }
        }
        return -1;
    }
}

/**
 * 三次样条插值器 Vector3
 */
class CubicInterpolator extends Interpolator {
    points;
    time;
    xPoints = [];
    yPoints = [];
    zPoints = [];
    cubicInterpolator2x = new CubicInterpolator2();
    cubicInterpolator2y = new CubicInterpolator2();
    cubicInterpolator2z = new CubicInterpolator2();
    interpolate(t, outer) {
        if (t < this.time[0]) {
            return null;
        }
        else if (t > this.time[this.points.length - 1]) {
            return null;
        }
        if (outer == undefined)
            outer = new Vector();
        this.findIndex(t);
        outer.x = this.cubicInterpolator2x.interpolate(t);
        outer.y = this.cubicInterpolator2y.interpolate(t);
        outer.z = this.cubicInterpolator2z.interpolate(t);
        return outer;
    }
    reCompute(points, time) {
        // 赋值与合法性校验
        if (points && time) {
            this.points = points;
            this.time = time;
        }
        else if (this.points && this.time) {
            points = this.points;
            time = this.time;
        }
        else {
            console.error("[CubicInterpolator] No points or time to compute.");
            return;
        }
        // 拆解轴
        this.xPoints.length = 0;
        this.yPoints.length = 0;
        this.zPoints.length = 0;
        for (let i = 0; i < points.length; i++) {
            this.xPoints.push(new Vector2(time[i], points[i].x));
            this.yPoints.push(new Vector2(time[i], points[i].y));
            this.zPoints.push(new Vector2(time[i], points[i].z));
        }
        this.cubicInterpolator2x.reCompute(this.xPoints);
        this.cubicInterpolator2y.reCompute(this.yPoints);
        this.cubicInterpolator2z.reCompute(this.zPoints);
        return this;
    }
    findIndex(t) {
        for (let i = 0; i < this.time.length; i++) {
            if (this.time[i] - t > 0) {
                return i - 1;
            }
        }
        return -1;
    }
}

/**
 * 线性插值器
 */
class LinearInterpolator extends Interpolator {
    _pointsA;
    _pointsB;
    interpolateValue(a, b, t) {
        return a + (b - a) * t;
    }
    interpolate(t, outer) {
        if (outer == undefined)
            outer = new Vector();
        outer.x = this.interpolateValue(this._pointsA.x, this._pointsB.x, t);
        outer.y = this.interpolateValue(this._pointsA.y, this._pointsB.y, t);
        outer.z = this.interpolateValue(this._pointsA.z, this._pointsB.z, t);
        return outer;
    }
    reCompute(a, b) {
        this._pointsA = a;
        this._pointsB = b;
        return this;
    }
}

exports.Assets = Assets;
exports.CSConfig = CSConfig;
exports.CSEditedPlayer = CSEditedPlayer;
exports.CSEditor = CSEditor;
exports.CSPlayer = CSPlayer;
exports.CSSettings = CSSettings;
exports.CameraAnchor = CameraAnchor;
exports.CameraCG = CameraCG;
exports.CameraProxy = CameraProxy;
exports.CubicInterpolator = CubicInterpolator;
exports.CubicInterpolator2 = CubicInterpolator2;
exports.GoPool = GoPool;
exports.GridContainer = GridContainer;
exports.GridSelectContainer = GridSelectContainer;
exports.Interpolator = Interpolator;
exports.KeyActionManager = KeyActionManager;
exports.KeyFrame = KeyFrame;
exports.KeyFrameInfo = KeyFrameInfo;
exports.LinearInterpolator = LinearInterpolator;
exports.Log = Log;
exports.MyQuaternion = MyQuaternion;
exports.UICSDialog = UICSDialog;
exports.UICSDialogLoad = UICSDialogLoad;
exports.UICSDialogSave = UICSDialogSave;
exports.UICSEditor = UICSEditor;
exports.UIKeyFrame = UIKeyFrame;
exports.UIPool = UIPool;
exports.UITimePoint = UITimePoint;
exports.UITimeText = UITimeText;
exports.UIUtils = UIUtils;
//# sourceMappingURL=index.js.map
